'use strict';

var jsxRuntime = require('react/jsx-runtime');
var react = require('react');
var reactTable = require('@tanstack/react-table');
var matchSorterUtils = require('@tanstack/match-sorter-utils');
var reactVirtual = require('@tanstack/react-virtual');
var iconsReact = require('@tabler/icons-react');
var core = require('@mantine/core');
var clsx = require('clsx');
var hooks = require('@mantine/hooks');
var dates = require('@mantine/dates');

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol */

function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
}
typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

const MRT_AggregationFns = Object.assign({}, reactTable.aggregationFns);

const fuzzy$1 = (row, columnId, filterValue, addMeta) => {
    const itemRank = matchSorterUtils.rankItem(row.getValue(columnId), filterValue, {
        threshold: matchSorterUtils.rankings.MATCHES,
    });
    addMeta(itemRank);
    return itemRank.passed;
};
fuzzy$1.autoRemove = (val) => !val;
const contains = (row, id, filterValue) => row
    .getValue(id)
    .toString()
    .toLowerCase()
    .trim()
    .includes(filterValue.toString().toLowerCase().trim());
contains.autoRemove = (val) => !val;
const startsWith = (row, id, filterValue) => row
    .getValue(id)
    .toString()
    .toLowerCase()
    .trim()
    .startsWith(filterValue.toString().toLowerCase().trim());
startsWith.autoRemove = (val) => !val;
const endsWith = (row, id, filterValue) => row
    .getValue(id)
    .toString()
    .toLowerCase()
    .trim()
    .endsWith(filterValue.toString().toLowerCase().trim());
endsWith.autoRemove = (val) => !val;
const equals = (row, id, filterValue) => filterValue === null
    ? true
    : row.getValue(id).toString().toLowerCase().trim() ===
        filterValue.toString().toLowerCase().trim();
equals.autoRemove = (val) => !val;
const notEquals = (row, id, filterValue) => row.getValue(id).toString().toLowerCase().trim() !==
    filterValue.toString().toLowerCase().trim();
notEquals.autoRemove = (val) => !val;
const greaterThan = (row, id, filterValue) => filterValue === null
    ? true
    : !isNaN(+filterValue) && !isNaN(+row.getValue(id))
        ? +row.getValue(id) > +filterValue
        : row.getValue(id).toString().toLowerCase().trim() >
            filterValue.toString().toLowerCase().trim();
greaterThan.autoRemove = (val) => !val;
const greaterThanOrEqualTo = (row, id, filterValue) => equals(row, id, filterValue) || greaterThan(row, id, filterValue);
greaterThanOrEqualTo.autoRemove = (val) => !val;
const lessThan = (row, id, filterValue) => filterValue === null
    ? true
    : !isNaN(+filterValue) && !isNaN(+row.getValue(id))
        ? +row.getValue(id) < +filterValue
        : row.getValue(id).toString().toLowerCase().trim() <
            filterValue.toString().toLowerCase().trim();
lessThan.autoRemove = (val) => !val;
const lessThanOrEqualTo = (row, id, filterValue) => equals(row, id, filterValue) || lessThan(row, id, filterValue);
lessThanOrEqualTo.autoRemove = (val) => !val;
const between = (row, id, filterValues) => (['', undefined].includes(filterValues[0]) ||
    greaterThan(row, id, filterValues[0])) &&
    ((!isNaN(+filterValues[0]) &&
        !isNaN(+filterValues[1]) &&
        +filterValues[0] > +filterValues[1]) ||
        ['', undefined].includes(filterValues[1]) ||
        lessThan(row, id, filterValues[1]));
between.autoRemove = (val) => !val;
const betweenInclusive = (row, id, filterValues) => (['', undefined].includes(filterValues[0]) ||
    greaterThanOrEqualTo(row, id, filterValues[0])) &&
    ((!isNaN(+filterValues[0]) &&
        !isNaN(+filterValues[1]) &&
        +filterValues[0] > +filterValues[1]) ||
        ['', undefined].includes(filterValues[1]) ||
        lessThanOrEqualTo(row, id, filterValues[1]));
betweenInclusive.autoRemove = (val) => !val;
const empty = (row, id, _filterValue) => !row.getValue(id).toString().trim();
empty.autoRemove = (val) => !val;
const notEmpty = (row, id, _filterValue) => !!row.getValue(id).toString().trim();
notEmpty.autoRemove = (val) => !val;
const MRT_FilterFns = Object.assign(Object.assign({}, reactTable.filterFns), { between,
    betweenInclusive,
    contains,
    empty,
    endsWith,
    equals,
    fuzzy: fuzzy$1,
    greaterThan,
    greaterThanOrEqualTo,
    lessThan,
    lessThanOrEqualTo,
    notEmpty,
    notEquals,
    startsWith });
function localizedFilterOption(localization, option) {
    var _a;
    if (!option) {
        return '';
    }
    const key = `filter${option[0].toUpperCase()}${option.slice(1)}`;
    return (_a = localization[key]) !== null && _a !== void 0 ? _a : '';
}

const fuzzy = (rowA, rowB, columnId) => {
    let dir = 0;
    if (rowA.columnFiltersMeta[columnId]) {
        dir = matchSorterUtils.compareItems(rowA.columnFiltersMeta[columnId], rowB.columnFiltersMeta[columnId]);
    }
    // Provide a fallback for when the item ranks are equal
    return dir === 0
        ? reactTable.sortingFns.alphanumeric(rowA, rowB, columnId)
        : dir;
};
const MRT_SortingFns = Object.assign(Object.assign({}, reactTable.sortingFns), { fuzzy });
const rankGlobalFuzzy = (rowA, rowB) => Math.max(...Object.values(rowB.columnFiltersMeta).map((v) => v.rank)) -
    Math.max(...Object.values(rowA.columnFiltersMeta).map((v) => v.rank));

const getColumnId = (columnDef) => { var _a, _b, _c, _d; return (_d = (_a = columnDef.id) !== null && _a !== void 0 ? _a : (_c = (_b = columnDef.accessorKey) === null || _b === void 0 ? void 0 : _b.toString) === null || _c === void 0 ? void 0 : _c.call(_b)) !== null && _d !== void 0 ? _d : columnDef.header; };
const getAllLeafColumnDefs = (columns) => {
    const allLeafColumnDefs = [];
    const getLeafColumns = (cols) => {
        cols.forEach((col) => {
            if (col.columns) {
                getLeafColumns(col.columns);
            }
            else {
                allLeafColumnDefs.push(col);
            }
        });
    };
    getLeafColumns(columns);
    return allLeafColumnDefs;
};
const prepareColumns = ({ aggregationFns, columnDefs, columnFilterFns, defaultDisplayColumn, filterFns, sortingFns, }) => columnDefs.map((columnDef) => {
    var _a, _b;
    //assign columnId
    if (!columnDef.id)
        columnDef.id = getColumnId(columnDef);
    if (process.env.NODE_ENV !== 'production' && !columnDef.id) {
        console.error('Column definitions must have a valid `accessorKey` or `id` property');
    }
    //assign columnDefType
    if (!columnDef.columnDefType)
        columnDef.columnDefType = 'data';
    if ((_a = columnDef.columns) === null || _a === void 0 ? void 0 : _a.length) {
        columnDef.columnDefType = 'group';
        //recursively prepare columns if this is a group column
        columnDef.columns = prepareColumns({
            aggregationFns,
            columnDefs: columnDef.columns,
            columnFilterFns,
            defaultDisplayColumn,
            filterFns,
            sortingFns,
        });
    }
    else if (columnDef.columnDefType === 'data') {
        //assign aggregationFns if multiple aggregationFns are provided
        if (Array.isArray(columnDef.aggregationFn)) {
            const aggFns = columnDef.aggregationFn;
            columnDef.aggregationFn = (columnId, leafRows, childRows) => aggFns.map((fn) => { var _a; return (_a = aggregationFns[fn]) === null || _a === void 0 ? void 0 : _a.call(aggregationFns, columnId, leafRows, childRows); });
        }
        //assign filterFns
        if (Object.keys(filterFns).includes(columnFilterFns[columnDef.id])) {
            columnDef.filterFn =
                (_b = filterFns[columnFilterFns[columnDef.id]]) !== null && _b !== void 0 ? _b : filterFns.fuzzy;
            columnDef._filterFn =
                columnFilterFns[columnDef.id];
        }
        //assign sortingFns
        if (Object.keys(sortingFns).includes(columnDef.sortingFn)) {
            // @ts-ignore
            columnDef.sortingFn = sortingFns[columnDef.sortingFn];
        }
    }
    else if (columnDef.columnDefType === 'display') {
        columnDef = Object.assign(Object.assign({}, defaultDisplayColumn), columnDef);
    }
    return columnDef;
});
const reorderColumn = (draggedColumn, targetColumn, columnOrder) => {
    if (draggedColumn.getCanPin()) {
        draggedColumn.pin(targetColumn.getIsPinned());
    }
    const newColumnOrder = [...columnOrder];
    newColumnOrder.splice(newColumnOrder.indexOf(targetColumn.id), 0, newColumnOrder.splice(newColumnOrder.indexOf(draggedColumn.id), 1)[0]);
    return newColumnOrder;
};
const showExpandColumn = (props, grouping) => !!(props.enableExpanding ||
    (props.enableGrouping && (grouping === undefined || (grouping === null || grouping === void 0 ? void 0 : grouping.length))) ||
    props.renderDetailPanel);
const getLeadingDisplayColumnIds = (props) => {
    var _a, _b;
    return [
        props.enableRowPinning &&
            !((_a = props.rowPinningDisplayMode) === null || _a === void 0 ? void 0 : _a.startsWith('select')) &&
            'mrt-row-pin',
        (props.enableRowDragging || props.enableRowOrdering) && 'mrt-row-drag',
        props.positionActionsColumn === 'first' &&
            (props.enableRowActions ||
                (props.enableEditing &&
                    ['row', 'modal', 'custom'].includes((_b = props.editDisplayMode) !== null && _b !== void 0 ? _b : ''))) &&
            'mrt-row-actions',
        props.positionExpandColumn === 'first' &&
            showExpandColumn(props) &&
            'mrt-row-expand',
        props.enableRowSelection && 'mrt-row-select',
        props.enableRowNumbers && 'mrt-row-numbers',
    ].filter(Boolean);
};
const getTrailingDisplayColumnIds = (props) => {
    var _a;
    return [
        props.positionActionsColumn === 'last' &&
            (props.enableRowActions ||
                (props.enableEditing &&
                    ['modal', 'row'].includes((_a = props.editDisplayMode) !== null && _a !== void 0 ? _a : ''))) &&
            'mrt-row-actions',
        props.positionExpandColumn === 'last' &&
            showExpandColumn(props) &&
            'mrt-row-expand',
        props.layoutMode === 'grid-no-grow' && 'mrt-row-spacer',
    ].filter(Boolean);
};
const getDefaultColumnOrderIds = (props) => {
    const leadingDisplayCols = getLeadingDisplayColumnIds(props);
    const trailingDisplayCols = getTrailingDisplayColumnIds(props);
    const allLeafColumnDefs = getAllLeafColumnDefs(props.columns)
        .map((columnDef) => getColumnId(columnDef))
        .filter((columnId) => !leadingDisplayCols.includes(columnId) &&
        !trailingDisplayCols.includes(columnId));
    return [...leadingDisplayCols, ...allLeafColumnDefs, ...trailingDisplayCols];
};
const getDefaultColumnFilterFn = (columnDef) => {
    const { filterVariant } = columnDef;
    if (filterVariant === 'multi-select')
        return 'arrIncludesSome';
    if (['range', 'date-range', 'range-slider'].includes(filterVariant || ''))
        return 'betweenInclusive';
    if (['select', 'checkbox', 'date'].includes(filterVariant || ''))
        return 'equals';
    return 'fuzzy';
};
const getIsFirstColumn = (column, table) => {
    const leftColumns = table.getLeftVisibleLeafColumns();
    return leftColumns.length
        ? leftColumns[0].id === column.id
        : table.getVisibleLeafColumns()[0].id === column.id;
};
const getIsLastColumn = (column, table) => {
    const rightColumns = table.getRightVisibleLeafColumns();
    const columns = table.getVisibleLeafColumns();
    return rightColumns.length
        ? rightColumns[rightColumns.length - 1].id === column.id
        : columns[columns.length - 1].id === column.id;
};
const getIsLastLeftPinnedColumn = (table, column) => {
    return (column.getIsPinned() === 'left' &&
        table.getLeftLeafHeaders().length - 1 === column.getPinnedIndex());
};
const getIsFirstRightPinnedColumn = (column) => {
    return column.getIsPinned() === 'right' && column.getPinnedIndex() === 0;
};
const getTotalRight = (table, column) => {
    return table
        .getRightLeafHeaders()
        .slice(column.getPinnedIndex() + 1)
        .reduce((acc, col) => acc + col.getSize(), 0);
};
const getCanRankRows = (table) => {
    const { getState, options } = table;
    const { enableGlobalFilterRankedResults, manualExpanding, manualFiltering, manualGrouping, manualSorting, } = options;
    const { expanded, globalFilterFn } = getState();
    return (!manualExpanding &&
        !manualFiltering &&
        !manualGrouping &&
        !manualSorting &&
        enableGlobalFilterRankedResults &&
        globalFilterFn === 'fuzzy' &&
        expanded !== true &&
        !Object.values(expanded).some(Boolean));
};
const MRT_DefaultColumn = {
    filterVariant: 'text',
    minSize: 40,
    maxSize: 1000,
    size: 180,
};
const MRT_DefaultDisplayColumn = {
    columnDefType: 'display',
    enableClickToCopy: false,
    enableColumnActions: false,
    enableColumnDragging: false,
    enableColumnFilter: false,
    enableColumnOrdering: false,
    enableEditing: false,
    enableGlobalFilter: false,
    enableGrouping: false,
    enableHiding: false,
    enableResizing: false,
    enableSorting: false,
};
function parseFromValuesOrFunc(fn, arg) {
    return fn instanceof Function ? fn(arg) : fn;
}
const parseCSSVarId = (id) => id.replace(/[^a-zA-Z0-9]/g, '_');
const getPrimaryShade = (theme) => {
    var _a, _b;
    return typeof theme.primaryShade === 'number'
        ? theme.primaryShade
        : (_b = (_a = theme.primaryShade) === null || _a === void 0 ? void 0 : _a.dark) !== null && _b !== void 0 ? _b : 7;
};
const getPrimaryColor = (theme, shade) => theme.colors[theme.primaryColor][shade !== null && shade !== void 0 ? shade : getPrimaryShade(theme)];
const flexRender = reactTable.flexRender;
const createRow = (table, originalRow) => reactTable.createRow(table, 'mrt-row-create', originalRow !== null && originalRow !== void 0 ? originalRow : Object.assign({}, ...getAllLeafColumnDefs(table.options.columns)
    .filter((c) => c.columnDefType === 'data')
    .map((col) => ({
    [getColumnId(col)]: '',
}))), -1, 0);
const extraIndexRangeExtractor = (range, draggingIndex) => {
    const newIndexes = reactVirtual.defaultRangeExtractor(range);
    if (draggingIndex === undefined)
        return newIndexes;
    if (draggingIndex >= 0 &&
        draggingIndex < Math.max(range.startIndex - range.overscan, 0)) {
        newIndexes.unshift(draggingIndex);
    }
    if (draggingIndex >= 0 && draggingIndex > range.endIndex + range.overscan) {
        newIndexes.push(draggingIndex);
    }
    return newIndexes;
};
function createMRTColumnHelper() {
    return {
        accessor: (accessor, column) => {
            return typeof accessor === 'function'
                ? Object.assign(Object.assign({}, column), { accessorFn: accessor })
                : Object.assign(Object.assign({}, column), { accessorKey: accessor });
        },
        display: (column) => column,
        group: (column) => column,
    };
}
const getValueAndLabel = (option) => {
    var _a, _b, _c;
    let label = '';
    let value = '';
    if (option) {
        if (typeof option !== 'object') {
            label = option;
            value = option;
        }
        else {
            label = (_b = (_a = option.label) !== null && _a !== void 0 ? _a : option.text) !== null && _b !== void 0 ? _b : option.value;
            value = (_c = option.value) !== null && _c !== void 0 ? _c : label;
        }
    }
    return { label, value };
};

const MRT_Localization_EN = {
    actions: 'Actions',
    and: 'and',
    cancel: 'Cancel',
    changeFilterMode: 'Change filter mode',
    changeSearchMode: 'Change search mode',
    clearFilter: 'Clear filter',
    clearSearch: 'Clear search',
    clearSort: 'Clear sort',
    clickToCopy: 'Click to copy',
    collapse: 'Collapse',
    collapseAll: 'Collapse all',
    columnActions: 'Column Actions',
    copiedToClipboard: 'Copied to clipboard',
    dropToGroupBy: 'Drop to group by {column}',
    edit: 'Edit',
    expand: 'Expand',
    expandAll: 'Expand all',
    filterArrIncludes: 'Includes',
    filterArrIncludesAll: 'Includes all',
    filterArrIncludesSome: 'Includes',
    filterBetween: 'Between',
    filterBetweenInclusive: 'Between Inclusive',
    filterByColumn: 'Filter by {column}',
    filterContains: 'Contains',
    filterEmpty: 'Empty',
    filterEndsWith: 'Ends With',
    filterEquals: 'Equals',
    filterEqualsString: 'Equals',
    filterFuzzy: 'Fuzzy',
    filterGreaterThan: 'Greater Than',
    filterGreaterThanOrEqualTo: 'Greater Than Or Equal To',
    filterInNumberRange: 'Between',
    filterIncludesString: 'Contains',
    filterIncludesStringSensitive: 'Contains',
    filterLessThan: 'Less Than',
    filterLessThanOrEqualTo: 'Less Than Or Equal To',
    filterMode: 'Filter Mode: {filterType}',
    filterNotEmpty: 'Not Empty',
    filterNotEquals: 'Not Equals',
    filterStartsWith: 'Starts With',
    filterWeakEquals: 'Equals',
    filteringByColumn: 'Filtering by {column} - {filterType} {filterValue}',
    goToFirstPage: 'Go to first page',
    goToLastPage: 'Go to last page',
    goToNextPage: 'Go to next page',
    goToPreviousPage: 'Go to previous page',
    grab: 'Grab',
    groupByColumn: 'Group by {column}',
    groupedBy: 'Grouped by ',
    hideAll: 'Hide all',
    hideColumn: 'Hide {column} column',
    max: 'Max',
    min: 'Min',
    move: 'Move',
    noRecordsToDisplay: 'No records to display',
    noResultsFound: 'No results found',
    of: 'of',
    or: 'or',
    pin: 'Pin',
    pinToLeft: 'Pin to left',
    pinToRight: 'Pin to right',
    resetColumnSize: 'Reset column size',
    resetOrder: 'Reset order',
    rowActions: 'Row Actions',
    rowNumber: '#',
    rowNumbers: 'Row Numbers',
    rowsPerPage: 'Rows per page',
    save: 'Save',
    search: 'Search',
    selectedCountOfRowCountRowsSelected: '{selectedCount} of {rowCount} row(s) selected',
    select: 'Select',
    showAll: 'Show all',
    showAllColumns: 'Show all columns',
    showHideColumns: 'Show/Hide columns',
    showHideFilters: 'Show/Hide filters',
    showHideSearch: 'Show/Hide search',
    sortByColumnAsc: 'Sort by {column} ascending',
    sortByColumnDesc: 'Sort by {column} descending',
    sortedByColumnAsc: 'Sorted by {column} ascending',
    sortedByColumnDesc: 'Sorted by {column} descending',
    thenBy: ', then by ',
    toggleDensity: 'Toggle density',
    toggleFullScreen: 'Toggle full screen',
    toggleSelectAll: 'Toggle select all',
    toggleSelectRow: 'Toggle select row',
    toggleVisibility: 'Toggle visibility',
    ungroupByColumn: 'Ungroup by {column}',
    unpin: 'Unpin',
    unpinAll: 'Unpin all',
};

const MRT_Default_Icons = {
    IconArrowAutofitContent: iconsReact.IconArrowAutofitContent,
    IconArrowsSort: iconsReact.IconArrowsSort,
    IconBaselineDensityLarge: iconsReact.IconBaselineDensityLarge,
    IconBaselineDensityMedium: iconsReact.IconBaselineDensityMedium,
    IconBaselineDensitySmall: iconsReact.IconBaselineDensitySmall,
    IconBoxMultiple: iconsReact.IconBoxMultiple,
    IconChevronDown: iconsReact.IconChevronDown,
    IconChevronLeft: iconsReact.IconChevronLeft,
    IconChevronLeftPipe: iconsReact.IconChevronLeftPipe,
    IconChevronRight: iconsReact.IconChevronRight,
    IconChevronRightPipe: iconsReact.IconChevronRightPipe,
    IconChevronsDown: iconsReact.IconChevronsDown,
    IconCircleX: iconsReact.IconCircleX,
    IconClearAll: iconsReact.IconClearAll,
    IconColumns: iconsReact.IconColumns,
    IconDeviceFloppy: iconsReact.IconDeviceFloppy,
    IconDots: iconsReact.IconDots,
    IconDotsVertical: iconsReact.IconDotsVertical,
    IconEdit: iconsReact.IconEdit,
    IconEyeOff: iconsReact.IconEyeOff,
    IconFilter: iconsReact.IconFilter,
    IconFilterCog: iconsReact.IconFilterCog,
    IconFilterOff: iconsReact.IconFilterOff,
    IconGripHorizontal: iconsReact.IconGripHorizontal,
    IconMaximize: iconsReact.IconMaximize,
    IconMinimize: iconsReact.IconMinimize,
    IconPinned: iconsReact.IconPinned,
    IconPinnedOff: iconsReact.IconPinnedOff,
    IconSearch: iconsReact.IconSearch,
    IconSearchOff: iconsReact.IconSearchOff,
    IconSortAscending: iconsReact.IconSortAscending,
    IconSortDescending: iconsReact.IconSortDescending,
    IconX: iconsReact.IconX,
};

const useMRT_TableOptions = (_a) => {
    var _b;
    var { aggregationFns, autoResetExpanded = false, columnFilterDisplayMode = 'subheader', columnResizeDirection, columnResizeMode = 'onChange', createDisplayMode = 'modal', defaultColumn, defaultDisplayColumn, editDisplayMode = 'modal', enableBottomToolbar = true, enableColumnActions = true, enableColumnFilters = true, enableColumnOrdering = false, enableColumnPinning = false, enableColumnResizing = false, enableDensityToggle = true, enableExpandAll = true, enableExpanding, enableFilterMatchHighlighting = true, enableFilters = true, enableFullScreenToggle = true, enableGlobalFilter = true, enableGlobalFilterRankedResults = true, enableGrouping = false, enableHiding = true, enableMultiRowSelection = true, enableMultiSort = true, enablePagination = true, enableRowSelection = false, enableSelectAll = true, enableSorting = true, enableStickyHeader = false, enableTableFooter = true, enableTableHead = true, enableToolbarInternalActions = true, enableTopToolbar = true, filterFns, icons, layoutMode, localization, manualFiltering, manualGrouping, manualPagination, manualSorting, paginationDisplayMode = 'default', positionActionsColumn = 'first', positionExpandColumn = 'first', positionGlobalFilter = 'right', positionPagination = 'bottom', positionToolbarAlertBanner = 'top', positionToolbarDropZone = 'top', rowNumberDisplayMode = 'static', rowPinningDisplayMode = 'sticky', selectAllMode = 'page', sortingFns } = _a, rest = __rest(_a, ["aggregationFns", "autoResetExpanded", "columnFilterDisplayMode", "columnResizeDirection", "columnResizeMode", "createDisplayMode", "defaultColumn", "defaultDisplayColumn", "editDisplayMode", "enableBottomToolbar", "enableColumnActions", "enableColumnFilters", "enableColumnOrdering", "enableColumnPinning", "enableColumnResizing", "enableDensityToggle", "enableExpandAll", "enableExpanding", "enableFilterMatchHighlighting", "enableFilters", "enableFullScreenToggle", "enableGlobalFilter", "enableGlobalFilterRankedResults", "enableGrouping", "enableHiding", "enableMultiRowSelection", "enableMultiSort", "enablePagination", "enableRowSelection", "enableSelectAll", "enableSorting", "enableStickyHeader", "enableTableFooter", "enableTableHead", "enableToolbarInternalActions", "enableTopToolbar", "filterFns", "icons", "layoutMode", "localization", "manualFiltering", "manualGrouping", "manualPagination", "manualSorting", "paginationDisplayMode", "positionActionsColumn", "positionExpandColumn", "positionGlobalFilter", "positionPagination", "positionToolbarAlertBanner", "positionToolbarDropZone", "rowNumberDisplayMode", "rowPinningDisplayMode", "selectAllMode", "sortingFns"]);
    const direction = core.useDirection();
    const _icons = react.useMemo(() => (Object.assign(Object.assign({}, MRT_Default_Icons), icons)), [icons]);
    const _localization = react.useMemo(() => (Object.assign(Object.assign({}, MRT_Localization_EN), localization)), [localization]);
    const _aggregationFns = react.useMemo(() => (Object.assign(Object.assign({}, MRT_AggregationFns), aggregationFns)), []);
    const _filterFns = react.useMemo(() => (Object.assign(Object.assign({}, MRT_FilterFns), filterFns)), []);
    const _sortingFns = react.useMemo(() => (Object.assign(Object.assign({}, MRT_SortingFns), sortingFns)), []);
    const _defaultColumn = react.useMemo(() => (Object.assign(Object.assign({}, MRT_DefaultColumn), defaultColumn)), [defaultColumn]);
    const _defaultDisplayColumn = react.useMemo(() => (Object.assign(Object.assign({}, MRT_DefaultDisplayColumn), defaultDisplayColumn)), [defaultDisplayColumn]);
    if (!columnResizeDirection) {
        columnResizeDirection = direction.dir || 'ltr';
    }
    layoutMode =
        layoutMode || (enableColumnResizing ? 'grid-no-grow' : 'semantic');
    if (layoutMode === 'semantic' &&
        (rest.enableRowVirtualization || rest.enableColumnVirtualization)) {
        layoutMode = 'grid';
    }
    if (rest.enableRowVirtualization) {
        enableStickyHeader = true;
    }
    if (enablePagination === false && manualPagination === undefined) {
        manualPagination = true;
    }
    if (!((_b = rest.data) === null || _b === void 0 ? void 0 : _b.length)) {
        manualFiltering = true;
        manualGrouping = true;
        manualPagination = true;
        manualSorting = true;
    }
    return Object.assign({ aggregationFns: _aggregationFns, autoResetExpanded,
        columnFilterDisplayMode,
        columnResizeDirection,
        columnResizeMode,
        createDisplayMode, defaultColumn: _defaultColumn, defaultDisplayColumn: _defaultDisplayColumn, editDisplayMode,
        enableBottomToolbar,
        enableColumnActions,
        enableColumnFilters,
        enableColumnOrdering,
        enableColumnPinning,
        enableColumnResizing,
        enableDensityToggle,
        enableExpandAll,
        enableExpanding,
        enableFilterMatchHighlighting,
        enableFilters,
        enableFullScreenToggle,
        enableGlobalFilter,
        enableGlobalFilterRankedResults,
        enableGrouping,
        enableHiding,
        enableMultiRowSelection,
        enableMultiSort,
        enablePagination,
        enableRowSelection,
        enableSelectAll,
        enableSorting,
        enableStickyHeader,
        enableTableFooter,
        enableTableHead,
        enableToolbarInternalActions,
        enableTopToolbar, filterFns: _filterFns, icons: _icons, layoutMode, localization: _localization, manualFiltering,
        manualGrouping,
        manualPagination,
        manualSorting,
        paginationDisplayMode,
        positionActionsColumn,
        positionExpandColumn,
        positionGlobalFilter,
        positionPagination,
        positionToolbarAlertBanner,
        positionToolbarDropZone,
        rowNumberDisplayMode,
        rowPinningDisplayMode,
        selectAllMode, sortingFns: _sortingFns }, rest);
};

const MRT_RowPinButton = ({ pinningPosition, row, table, }) => {
    const { options: { icons: { IconX, IconPinned }, localization, rowPinningDisplayMode, }, } = table;
    const isPinned = row.getIsPinned();
    const [tooltipOpened, setTooltipOpened] = react.useState(false);
    const handleTogglePin = (event) => {
        setTooltipOpened(false);
        event.stopPropagation();
        row.pin(isPinned ? false : pinningPosition);
    };
    return (jsxRuntime.jsx(core.Tooltip, { opened: tooltipOpened, openDelay: 1000, label: isPinned ? localization.unpin : localization.pin, children: jsxRuntime.jsx(core.ActionIcon, { "aria-label": localization.pin, color: "gray", onClick: handleTogglePin, onMouseEnter: () => setTooltipOpened(true), onMouseLeave: () => setTooltipOpened(false), size: "xs", variant: "subtle", style: {
                height: '24px',
                width: '24px',
            }, children: isPinned ? (jsxRuntime.jsx(IconX, {})) : (jsxRuntime.jsx(IconPinned, { fontSize: "small", style: {
                    transform: `rotate(${rowPinningDisplayMode === 'sticky'
                        ? 135
                        : pinningPosition === 'top'
                            ? 180
                            : 0}deg)`,
                } })) }) }));
};

const MRT_TableBodyRowPinButton = ({ row, table, }) => {
    const { getState, options: { enableRowPinning, rowPinningDisplayMode }, } = table;
    const { density } = getState();
    const canPin = parseFromValuesOrFunc(enableRowPinning, row);
    if (!canPin)
        return null;
    if (rowPinningDisplayMode === 'top-and-bottom' && !row.getIsPinned()) {
        return (jsxRuntime.jsxs(core.Box, { style: {
                display: 'flex',
                flexDirection: density === 'xs' ? 'row' : 'column',
            }, children: [jsxRuntime.jsx(MRT_RowPinButton, { pinningPosition: "top", row: row, table: table }), jsxRuntime.jsx(MRT_RowPinButton, { pinningPosition: "bottom", row: row, table: table })] }));
    }
    return (jsxRuntime.jsx(MRT_RowPinButton, { pinningPosition: rowPinningDisplayMode === 'bottom' ? 'bottom' : 'top', row: row, table: table }));
};

const MRT_EditCellTextInput = ({ cell, table, }) => {
    var _a;
    const { getState, options: { createDisplayMode, editDisplayMode, mantineEditTextInputProps, mantineEditSelectProps, }, refs: { editInputRefs }, setEditingCell, setEditingRow, setCreatingRow, } = table;
    const { column, row } = cell;
    const { columnDef } = column;
    const { creatingRow, editingRow } = getState();
    const isCreating = (creatingRow === null || creatingRow === void 0 ? void 0 : creatingRow.id) === row.id;
    const isEditing = (editingRow === null || editingRow === void 0 ? void 0 : editingRow.id) === row.id;
    const isSelectEdit = columnDef.editVariant === 'select';
    const [value, setValue] = react.useState(() => cell.getValue());
    const arg = { cell, column, row, table };
    const textInputProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(mantineEditTextInputProps, arg)), parseFromValuesOrFunc(columnDef.mantineEditTextInputProps, arg));
    const selectProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(mantineEditSelectProps, arg)), parseFromValuesOrFunc(columnDef.mantineEditSelectProps, arg));
    const saveInputValueToRowCache = (newValue) => {
        //@ts-ignore
        row._valuesCache[column.id] = newValue;
        if (isCreating) {
            setCreatingRow(row);
        }
        else if (isEditing) {
            setEditingRow(row);
        }
    };
    const handleBlur = (event) => {
        var _a;
        (_a = textInputProps.onBlur) === null || _a === void 0 ? void 0 : _a.call(textInputProps, event);
        saveInputValueToRowCache(value);
        setEditingCell(null);
    };
    const handleEnterKeyDown = (event) => {
        var _a, _b;
        (_a = textInputProps.onKeyDown) === null || _a === void 0 ? void 0 : _a.call(textInputProps, event);
        if (event.key === 'Enter') {
            (_b = editInputRefs.current[cell.id]) === null || _b === void 0 ? void 0 : _b.blur();
        }
    };
    if (columnDef.Edit) {
        return (_a = columnDef.Edit) === null || _a === void 0 ? void 0 : _a.call(columnDef, { cell, column, row, table });
    }
    const commonProps = {
        disabled: parseFromValuesOrFunc(columnDef.enableEditing, row) === false,
        label: ['modal', 'custom'].includes((isCreating ? createDisplayMode : editDisplayMode))
            ? column.columnDef.header
            : undefined,
        name: cell.id,
        placeholder: !['modal', 'custom'].includes((isCreating ? createDisplayMode : editDisplayMode))
            ? columnDef.header
            : undefined,
        value,
        variant: editDisplayMode === 'table' ? 'unstyled' : 'default',
        onClick: (e) => {
            var _a;
            e.stopPropagation();
            (_a = textInputProps === null || textInputProps === void 0 ? void 0 : textInputProps.onClick) === null || _a === void 0 ? void 0 : _a.call(textInputProps, e);
        },
    };
    if (isSelectEdit) {
        return (
        // @ts-ignore
        jsxRuntime.jsx(core.Select, Object.assign({}, commonProps, { searchable: true, value: value }, selectProps, { onBlur: handleBlur, onChange: (value) => {
                var _a;
                (_a = selectProps.onChange) === null || _a === void 0 ? void 0 : _a.call(selectProps, value);
                setValue(value);
            }, onClick: (e) => {
                var _a;
                e.stopPropagation();
                (_a = selectProps === null || selectProps === void 0 ? void 0 : selectProps.onClick) === null || _a === void 0 ? void 0 : _a.call(selectProps, e);
            }, ref: (node) => {
                if (node) {
                    editInputRefs.current[cell.id] = node;
                    if (selectProps.ref) {
                        selectProps.ref.current = node;
                    }
                }
            } })));
    }
    return (jsxRuntime.jsx(core.TextInput, Object.assign({}, commonProps, { onKeyDown: handleEnterKeyDown, value: value !== null && value !== void 0 ? value : '' }, textInputProps, { onBlur: handleBlur, onChange: (event) => {
            var _a;
            (_a = textInputProps.onChange) === null || _a === void 0 ? void 0 : _a.call(textInputProps, event);
            setValue(event.target.value);
        }, onClick: (event) => {
            var _a;
            event.stopPropagation();
            (_a = textInputProps === null || textInputProps === void 0 ? void 0 : textInputProps.onClick) === null || _a === void 0 ? void 0 : _a.call(textInputProps, event);
        }, ref: (node) => {
            if (node) {
                editInputRefs.current[cell.id] = node;
                if (textInputProps.ref) {
                    textInputProps.ref.current = node;
                }
            }
        } })));
};

var classes$C = {"root":"MRT_CopyButton-module_root__jmas-"};

const MRT_CopyButton = ({ cell, children, table, }) => {
    const { options: { localization: { copiedToClipboard, clickToCopy }, mantineCopyButtonProps, }, } = table;
    const { column, row } = cell;
    const { columnDef } = column;
    const arg = { cell, column, row, table };
    const buttonProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(mantineCopyButtonProps, arg)), parseFromValuesOrFunc(columnDef.mantineCopyButtonProps, arg));
    return (jsxRuntime.jsx(core.CopyButton, { value: cell.getValue(), children: ({ copied, copy }) => {
            var _a;
            return (jsxRuntime.jsx(core.Tooltip, { color: copied ? 'green' : undefined, withinPortal: true, openDelay: 1000, label: (_a = buttonProps === null || buttonProps === void 0 ? void 0 : buttonProps.title) !== null && _a !== void 0 ? _a : (copied ? copiedToClipboard : clickToCopy), children: jsxRuntime.jsx(core.UnstyledButton, Object.assign({}, buttonProps, { className: clsx('mrt-copy-button', classes$C.root, buttonProps === null || buttonProps === void 0 ? void 0 : buttonProps.className), title: undefined, role: "presentation", onClick: (e) => {
                        e.stopPropagation();
                        copy();
                    }, children: children })) }));
        } }));
};

const allowedTypes = ['string', 'number'];
const allowedFilterVariants = ['text', 'autocomplete'];
const MRT_TableBodyCellValue = ({ cell, table, }) => {
    var _a, _b;
    const { getState, options: { enableFilterMatchHighlighting, mantineHighlightProps }, } = table;
    const { column, row } = cell;
    const { columnDef } = column;
    const { globalFilter, globalFilterFn } = getState();
    const filterValue = column.getFilterValue();
    const highlightProps = parseFromValuesOrFunc(mantineHighlightProps, {
        cell,
        column,
        row,
        table,
    });
    let renderedCellValue = cell.getIsAggregated() && columnDef.AggregatedCell
        ? columnDef.AggregatedCell({
            cell,
            column,
            row,
            table,
        })
        : row.getIsGrouped() && !cell.getIsGrouped()
            ? null
            : cell.getIsGrouped() && columnDef.GroupedCell
                ? columnDef.GroupedCell({
                    cell,
                    column,
                    row,
                    table,
                })
                : undefined;
    const isGroupedValue = renderedCellValue !== undefined;
    if (!isGroupedValue) {
        renderedCellValue = cell.renderValue();
    }
    if (enableFilterMatchHighlighting &&
        columnDef.enableFilterMatchHighlighting !== false &&
        renderedCellValue &&
        allowedTypes.includes(typeof renderedCellValue) &&
        ((filterValue &&
            allowedTypes.includes(typeof filterValue) &&
            allowedFilterVariants.includes(columnDef.filterVariant)) ||
            (globalFilter &&
                allowedTypes.includes(typeof globalFilter) &&
                column.getCanGlobalFilter()))) {
        let highlight = ((_b = (_a = column.getFilterValue()) !== null && _a !== void 0 ? _a : globalFilter) !== null && _b !== void 0 ? _b : '').toString();
        if ((filterValue ? columnDef._filterFn : globalFilterFn) === 'fuzzy') {
            highlight = highlight.split(' ');
        }
        renderedCellValue = (jsxRuntime.jsx(core.Highlight, Object.assign({ color: "yellow.3", highlight: highlight }, highlightProps, { children: renderedCellValue === null || renderedCellValue === void 0 ? void 0 : renderedCellValue.toString() })));
    }
    if (columnDef.Cell && !isGroupedValue) {
        renderedCellValue = columnDef.Cell({
            cell,
            renderedCellValue,
            column,
            row,
            table,
        });
    }
    return renderedCellValue;
};

var classes$B = {"root":"MRT_TableBodyCell-module_root__Pobyx","root-default-background":"MRT_TableBodyCell-module_root-default-background__uZLbT","root-inherit-background-color":"MRT_TableBodyCell-module_root-inherit-background-color__aqyHq","root-grid":"MRT_TableBodyCell-module_root-grid__O6-NK","root-data-col":"MRT_TableBodyCell-module_root-data-col__7jOUQ","root-nowrap":"MRT_TableBodyCell-module_root-nowrap__m62z6","root-cursor-pointer":"MRT_TableBodyCell-module_root-cursor-pointer__k4JUJ","root-editable-hover":"MRT_TableBodyCell-module_root-editable-hover__U29y5","root-virtualized":"MRT_TableBodyCell-module_root-virtualized__B3lV-","root-pinned":"MRT_TableBodyCell-module_root-pinned__mGPP6","root-pinned-left":"MRT_TableBodyCell-module_root-pinned-left__QVsHF","root-pinned-right":"MRT_TableBodyCell-module_root-pinned-right__PVC8z","root-pinned-left-last":"MRT_TableBodyCell-module_root-pinned-left-last__lcykV","root-pinned-right-first":"MRT_TableBodyCell-module_root-pinned-right-first__dtmfa","root-expand-depth":"MRT_TableBodyCell-module_root-expand-depth__Xri1r","dragging-column":"MRT_TableBodyCell-module_dragging-column__P2ynr","last-row":"MRT_TableBodyCell-module_last-row__UGl3c","hovered-column":"MRT_TableBodyCell-module_hovered-column__QXqfh","dragging-row":"MRT_TableBodyCell-module_dragging-row__kAFEx","last-column":"MRT_TableBodyCell-module_last-column__Y-71j","first-column":"MRT_TableBodyCell-module_first-column__miFMv","hovered-row":"MRT_TableBodyCell-module_hovered-row__doArj"};

const MRT_TableBodyCell = ({ cell, isStriped, measureElement, numRows, rowIndex, rowRef, table, virtualCell, }) => {
    var _a, _b, _c, _d;
    const { getState, options: { createDisplayMode, editDisplayMode, enableClickToCopy, enableColumnOrdering, enableColumnVirtualization, enableEditing, enableGrouping, layoutMode, mantineSkeletonProps, mantineTableBodyCellProps, }, refs: { editInputRefs }, setEditingCell, setHoveredColumn, } = table;
    const { creatingRow, density, draggingColumn, draggingRow, editingCell, editingRow, hoveredColumn, hoveredRow, isLoading, showSkeletons, } = getState();
    const { column, row } = cell;
    const { columnDef } = column;
    const { columnDefType } = columnDef;
    const arg = { cell, column, row, table };
    const tableCellProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(mantineTableBodyCellProps, arg)), parseFromValuesOrFunc(columnDef.mantineTableBodyCellProps, arg));
    const skeletonProps = parseFromValuesOrFunc(mantineSkeletonProps, arg);
    const [skeletonWidth, setSkeletonWidth] = react.useState(100);
    react.useEffect(() => {
        if ((!isLoading && !showSkeletons) || skeletonWidth !== 100)
            return;
        const size = column.getSize();
        setSkeletonWidth(columnDefType === 'display'
            ? size / 2
            : Math.round(Math.random() * (size - size / 3) + size / 3));
    }, [isLoading, showSkeletons]);
    const widthStyles = react.useMemo(() => {
        var _a;
        const styles = {
            minWidth: `max(calc(var(--col-${parseCSSVarId(column.id)}-size) * 1px), ${(_a = column.columnDef.minSize) !== null && _a !== void 0 ? _a : 30}px)`,
            width: `calc(var(--col-${parseCSSVarId(column.id)}-size) * 1px)`,
        };
        if (layoutMode === 'grid') {
            styles.flex = `${column.getSize()} 0 auto`;
        }
        else if (layoutMode === 'grid-no-grow') {
            styles.flex = '0 0 auto';
        }
        return styles;
    }, [column]);
    const isEditable = (parseFromValuesOrFunc(enableEditing, row) &&
        parseFromValuesOrFunc(columnDef.enableEditing, row)) !== false;
    const isEditing = isEditable &&
        !['modal', 'custom'].includes(editDisplayMode) &&
        (editDisplayMode === 'table' ||
            (editingRow === null || editingRow === void 0 ? void 0 : editingRow.id) === row.id ||
            (editingCell === null || editingCell === void 0 ? void 0 : editingCell.id) === cell.id) &&
        !row.getIsGrouped();
    const isCreating = isEditable && createDisplayMode === 'row' && (creatingRow === null || creatingRow === void 0 ? void 0 : creatingRow.id) === row.id;
    const handleDoubleClick = (event) => {
        var _a;
        (_a = tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.onDoubleClick) === null || _a === void 0 ? void 0 : _a.call(tableCellProps, event);
        if (isEditable && editDisplayMode === 'cell') {
            setEditingCell(cell);
            setTimeout(() => {
                var _a;
                const textField = editInputRefs.current[cell.id];
                if (textField) {
                    textField.focus();
                    (_a = textField.select) === null || _a === void 0 ? void 0 : _a.call(textField);
                }
            }, 100);
        }
    };
    const handleDragEnter = (e) => {
        var _a;
        (_a = tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.onDragEnter) === null || _a === void 0 ? void 0 : _a.call(tableCellProps, e);
        if (enableGrouping && (hoveredColumn === null || hoveredColumn === void 0 ? void 0 : hoveredColumn.id) === 'drop-zone') {
            setHoveredColumn(null);
        }
        if (enableColumnOrdering && draggingColumn) {
            setHoveredColumn(columnDef.enableColumnOrdering !== false ? column : null);
        }
    };
    return (jsxRuntime.jsxs(core.TableTd, Object.assign({ "data-index": virtualCell === null || virtualCell === void 0 ? void 0 : virtualCell.index, "data-pinned": column.getIsPinned() && column.columnDef.columnDefType !== 'group', ref: (node) => {
            if (node) {
                measureElement === null || measureElement === void 0 ? void 0 : measureElement(node);
            }
        } }, tableCellProps, { __vars: Object.assign({ '--mrt-table-cell-justify': (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith('grid'))
                ? tableCellProps.align === 'left'
                    ? 'flex-start'
                    : tableCellProps.align === 'right'
                        ? 'flex-end'
                        : tableCellProps.align
                : undefined, '--mrt-table-cell-left': column.getIsPinned() === 'left'
                ? `${column.getStart('left')}`
                : undefined, '--mrt-table-cell-right': column.getIsPinned() === 'right'
                ? `${getTotalRight(table, column)}`
                : undefined, '--mrt-row-depth': column.id === 'mrt-row-expand' ? `${row.depth}` : undefined }, tableCellProps.__vars), className: clsx(classes$B.root, isStriped || row.getIsSelected()
            ? classes$B['root-inherit-background-color']
            : classes$B['root-default-background'], (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith('grid')) && classes$B['root-grid'], isEditable &&
            editDisplayMode === 'cell' &&
            classes$B['root-cursor-pointer'], isEditable &&
            ['table', 'cell'].includes(editDisplayMode !== null && editDisplayMode !== void 0 ? editDisplayMode : '') &&
            columnDefType !== 'display' &&
            classes$B['root-editable-hover'], enableColumnVirtualization && classes$B['root-virtualized'], column.getIsPinned() &&
            column.columnDef.columnDefType !== 'group' &&
            classes$B['root-pinned'], column.getIsPinned() === 'left' && classes$B['root-pinned-left'], column.getIsPinned() === 'right' && classes$B['root-pinned-right'], getIsLastLeftPinnedColumn(table, column) &&
            classes$B['root-pinned-left-last'], getIsFirstRightPinnedColumn(column) &&
            classes$B['root-pinned-right-first'], column.id === 'mrt-row-expand' && classes$B['root-expand-depth'], columnDefType === 'data' && classes$B['root-data-col'], density === 'xs' && classes$B['root-nowrap'], (draggingColumn === null || draggingColumn === void 0 ? void 0 : draggingColumn.id) === column.id && classes$B['dragging-column'], (draggingColumn === null || draggingColumn === void 0 ? void 0 : draggingColumn.id) !== column.id &&
            (hoveredColumn === null || hoveredColumn === void 0 ? void 0 : hoveredColumn.id) === column.id &&
            classes$B['hovered-column'], (draggingRow === null || draggingRow === void 0 ? void 0 : draggingRow.id) === row.id && classes$B['dragging-row'], (draggingRow === null || draggingRow === void 0 ? void 0 : draggingRow.id) !== row.id &&
            (hoveredRow === null || hoveredRow === void 0 ? void 0 : hoveredRow.id) === row.id &&
            classes$B['hovered-row'], getIsFirstColumn(column, table) && classes$B['first-column'], getIsLastColumn(column, table) && classes$B['last-column'], numRows && rowIndex === numRows - 1 && classes$B['last-row'], tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.className), style: (theme) => (Object.assign(Object.assign({}, widthStyles), parseFromValuesOrFunc(tableCellProps.style, theme))), onDragEnter: handleDragEnter, onDoubleClick: handleDoubleClick, children: [jsxRuntime.jsx(jsxRuntime.Fragment, { children: cell.getIsPlaceholder() ? ((_b = (_a = columnDef.PlaceholderCell) === null || _a === void 0 ? void 0 : _a.call(columnDef, { cell, column, row, table })) !== null && _b !== void 0 ? _b : null) : isLoading || showSkeletons ? (jsxRuntime.jsx(core.Skeleton, Object.assign({ height: 20, width: skeletonWidth }, skeletonProps))) : columnDefType === 'display' &&
                    (['mrt-row-expand', 'mrt-row-numbers', 'mrt-row-select'].includes(column.id) ||
                        !row.getIsGrouped()) ? ((_c = columnDef.Cell) === null || _c === void 0 ? void 0 : _c.call(columnDef, {
                    cell,
                    column,
                    renderedCellValue: cell.renderValue(),
                    row,
                    rowRef,
                    staticRowIndex: rowIndex,
                    table,
                })) : isCreating || isEditing ? (jsxRuntime.jsx(MRT_EditCellTextInput, { cell: cell, table: table })) : (enableClickToCopy || columnDef.enableClickToCopy) &&
                    columnDef.enableClickToCopy !== false ? (jsxRuntime.jsx(MRT_CopyButton, { cell: cell, table: table, children: jsxRuntime.jsx(MRT_TableBodyCellValue, { cell: cell, table: table }) })) : (jsxRuntime.jsx(MRT_TableBodyCellValue, { cell: cell, table: table })) }), cell.getIsGrouped() && !columnDef.GroupedCell && (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [" (", (_d = row.subRows) === null || _d === void 0 ? void 0 : _d.length, ")"] }))] })));
};
const Memo_MRT_TableBodyCell = react.memo(MRT_TableBodyCell, (prev, next) => next.cell === prev.cell);

var classes$A = {"root":"MRT_TableDetailPanel-module_root__QOc-A","root-grid":"MRT_TableDetailPanel-module_root-grid__x81ws","root-virtual-row":"MRT_TableDetailPanel-module_root-virtual-row__gOdLd","inner":"MRT_TableDetailPanel-module_inner__Jt31u","inner-grid":"MRT_TableDetailPanel-module_inner-grid__Fx3MQ","inner-expanded":"MRT_TableDetailPanel-module_inner-expanded__sxlM1","inner-virtual":"MRT_TableDetailPanel-module_inner-virtual__-1POL"};

const MRT_TableDetailPanel = ({ parentRowRef, row, rowIndex, table, virtualRow, }) => {
    var _a, _b;
    const { getVisibleLeafColumns, getState, options: { layoutMode, mantineTableBodyRowProps, mantineDetailPanelProps, renderDetailPanel, }, } = table;
    const { isLoading } = getState();
    const tableRowProps = parseFromValuesOrFunc(mantineTableBodyRowProps, {
        isDetailPanel: true,
        row,
        staticRowIndex: rowIndex,
        table,
    });
    const tableCellProps = parseFromValuesOrFunc(mantineDetailPanelProps, {
        row,
        table,
    });
    const parentRowHeight = virtualRow
        ? (_b = (_a = parentRowRef.current) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect()) === null || _b === void 0 ? void 0 : _b.height
        : 0;
    return (jsxRuntime.jsx(core.Box, Object.assign({ component: "tr" }, tableRowProps, { __vars: Object.assign({ '--mrt-parent-row-height': virtualRow && parentRowHeight ? `${parentRowHeight}px` : undefined, '--mrt-virtual-row-start': virtualRow
                ? `${virtualRow.start}px`
                : undefined }, tableRowProps === null || tableRowProps === void 0 ? void 0 : tableRowProps.__vars), className: clsx('mantine-Table-tr-detail-panel', classes$A.root, (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith('grid')) && classes$A['root-grid'], virtualRow && classes$A['root-virtual-row'], tableRowProps === null || tableRowProps === void 0 ? void 0 : tableRowProps.className), children: jsxRuntime.jsx(core.Box, Object.assign({ component: "td", colSpan: getVisibleLeafColumns().length }, tableCellProps, { __vars: {
                '--mrt-inner-width': `${table.getTotalSize()}px`,
            }, className: clsx('mantine-Table-td-detail-panel', classes$A.inner, (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith('grid')) && classes$A['inner-grid'], row.getIsExpanded() && classes$A['inner-expanded'], virtualRow && classes$A['inner-virtual']), p: row.getIsExpanded() ? 'md' : 0, children: renderDetailPanel && (jsxRuntime.jsx(core.Collapse, { in: row.getIsExpanded(), children: !isLoading && renderDetailPanel({ row, table }) })) })) })));
};

var classes$z = {"root":"MRT_TableBodyRow-module_root__XFiaH","root-grid":"MRT_TableBodyRow-module_root-grid__O8---","root-hover":"MRT_TableBodyRow-module_root-hover__8i28-","root-pinned":"MRT_TableBodyRow-module_root-pinned__MDKin","root-sticky-pinned":"MRT_TableBodyRow-module_root-sticky-pinned__iWjBc","root-sticky-pinned-top":"MRT_TableBodyRow-module_root-sticky-pinned-top__euFae","root-sticky-pinned-bottom":"MRT_TableBodyRow-module_root-sticky-pinned-bottom__0cY2E","root-virtualized":"MRT_TableBodyRow-module_root-virtualized__U2ADn"};

const MRT_TableBodyRow = ({ columnVirtualizer, enableHover, isStriped, measureElement, numRows, row, rowIndex, table, pinnedRowIds, virtualRow, }) => {
    var _a, _b, _c;
    const { getState, options: { enableRowPinning, enableStickyFooter, enableStickyHeader, rowPinningDisplayMode, enableRowOrdering, layoutMode, memoMode, mantineTableBodyRowProps, renderDetailPanel, }, refs: { tableFooterRef, tableHeadRef }, setHoveredRow, } = table;
    const { density, draggingColumn, draggingRow, editingCell, editingRow, hoveredRow, isFullScreen, rowPinning, } = getState();
    const { virtualColumns, virtualPaddingLeft, virtualPaddingRight } = columnVirtualizer !== null && columnVirtualizer !== void 0 ? columnVirtualizer : {};
    const isPinned = enableRowPinning && row.getIsPinned();
    const tableRowProps = parseFromValuesOrFunc(mantineTableBodyRowProps, {
        row,
        staticRowIndex: rowIndex,
        table,
    });
    const [bottomPinnedIndex, topPinnedIndex] = react.useMemo(() => {
        if (!enableRowPinning ||
            !(rowPinningDisplayMode === null || rowPinningDisplayMode === void 0 ? void 0 : rowPinningDisplayMode.includes('sticky')) ||
            !pinnedRowIds ||
            !row.getIsPinned())
            return [];
        return [
            [...pinnedRowIds].reverse().indexOf(row.id),
            pinnedRowIds.indexOf(row.id),
        ];
    }, [pinnedRowIds, rowPinning]);
    const tableHeadHeight = ((enableStickyHeader || isFullScreen) &&
        ((_a = tableHeadRef.current) === null || _a === void 0 ? void 0 : _a.clientHeight)) ||
        0;
    const tableFooterHeight = (enableStickyFooter && ((_b = tableFooterRef.current) === null || _b === void 0 ? void 0 : _b.clientHeight)) || 0;
    const rowHeight = 
    // @ts-ignore
    parseInt((_c = tableRowProps === null || tableRowProps === void 0 ? void 0 : tableRowProps.style) === null || _c === void 0 ? void 0 : _c.height, 10) ||
        (density === 'xs' ? 37 : density === 'md' ? 53 : 69);
    const handleDragEnter = (_e) => {
        if (enableRowOrdering && draggingRow) {
            setHoveredRow(row);
        }
    };
    const rowRef = react.useRef(null);
    return (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsxs(core.TableTr, Object.assign({ "data-index": rowIndex, "data-selected": row.getIsSelected() || undefined, onDragEnter: handleDragEnter, ref: (node) => {
                    if (node) {
                        rowRef.current = node;
                        measureElement === null || measureElement === void 0 ? void 0 : measureElement(node);
                    }
                } }, tableRowProps, { __vars: Object.assign(Object.assign({}, tableRowProps === null || tableRowProps === void 0 ? void 0 : tableRowProps.__vars), { '--mrt-virtual-row-start': virtualRow
                        ? `${virtualRow.start}`
                        : undefined, '--mrt-pinned-row-top': virtualRow
                        ? '0'
                        : topPinnedIndex !== undefined && isPinned
                            ? `${topPinnedIndex * rowHeight +
                                (enableStickyHeader || isFullScreen ? tableHeadHeight - 1 : 0)}`
                            : undefined, '--mrt-pinned-row-bottom': !virtualRow && bottomPinnedIndex !== undefined && isPinned
                        ? `${bottomPinnedIndex * rowHeight +
                            (enableStickyFooter ? tableFooterHeight - 1 : 0)}`
                        : undefined }), className: clsx(classes$z.root, (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith('grid')) && classes$z['root-grid'], virtualRow && classes$z['root-virtualized'], ((draggingRow === null || draggingRow === void 0 ? void 0 : draggingRow.id) === row.id || (hoveredRow === null || hoveredRow === void 0 ? void 0 : hoveredRow.id) === row.id) &&
                    classes$z['root-dragging'], enableHover !== false && classes$z['root-hover'], tableRowProps === null || tableRowProps === void 0 ? void 0 : tableRowProps.className, isPinned && classes$z['root-pinned'], !virtualRow &&
                    isPinned &&
                    (rowPinningDisplayMode === null || rowPinningDisplayMode === void 0 ? void 0 : rowPinningDisplayMode.includes('sticky')) &&
                    classes$z['root-sticky-pinned'], !virtualRow &&
                    isPinned &&
                    (rowPinningDisplayMode === null || rowPinningDisplayMode === void 0 ? void 0 : rowPinningDisplayMode.includes('sticky')) &&
                    bottomPinnedIndex !== undefined &&
                    classes$z['root-sticky-pinned-top'], !virtualRow &&
                    isPinned &&
                    (rowPinningDisplayMode === null || rowPinningDisplayMode === void 0 ? void 0 : rowPinningDisplayMode.includes('sticky')) &&
                    topPinnedIndex !== undefined &&
                    classes$z['root-sticky-pinned-bottom']), children: [virtualPaddingLeft ? (jsxRuntime.jsx(core.Box, { component: "td", display: "flex", w: virtualPaddingLeft })) : null, (virtualColumns !== null && virtualColumns !== void 0 ? virtualColumns : row.getVisibleCells()).map((cellOrVirtualCell) => {
                        var _a, _b;
                        const cell = columnVirtualizer
                            ? row.getVisibleCells()[cellOrVirtualCell.index]
                            : cellOrVirtualCell;
                        const props = {
                            cell,
                            isStriped,
                            measureElement: columnVirtualizer === null || columnVirtualizer === void 0 ? void 0 : columnVirtualizer.measureElement,
                            numRows,
                            rowIndex,
                            rowRef,
                            table,
                            virtualCell: columnVirtualizer
                                ? cellOrVirtualCell
                                : undefined,
                        };
                        return memoMode === 'cells' &&
                            cell.column.columnDef.columnDefType === 'data' &&
                            !draggingColumn &&
                            !draggingRow &&
                            (editingCell === null || editingCell === void 0 ? void 0 : editingCell.id) !== cell.id &&
                            (editingRow === null || editingRow === void 0 ? void 0 : editingRow.id) !== row.id ? (jsxRuntime.jsx(Memo_MRT_TableBodyCell, Object.assign({}, props), cell.id + ((_a = cell.getValue()) === null || _a === void 0 ? void 0 : _a.toString()))) : (jsxRuntime.jsx(MRT_TableBodyCell, Object.assign({}, props), cell.id + ((_b = cell.getValue) === null || _b === void 0 ? void 0 : _b.toString())));
                    }), virtualPaddingRight ? (jsxRuntime.jsx(core.Box, { component: "td", display: "flex", w: virtualPaddingRight })) : null] })), renderDetailPanel && !row.getIsGrouped() && (jsxRuntime.jsx(MRT_TableDetailPanel, { parentRowRef: rowRef, row: row, rowIndex: rowIndex, table: table, virtualRow: virtualRow }))] }));
};
const Memo_MRT_TableBodyRow = react.memo(MRT_TableBodyRow, (prev, next) => prev.row === next.row && prev.rowIndex === next.rowIndex);

var classes$y = {"root":"MRT_TableBody-module_root__ZWGrL","root-grid":"MRT_TableBody-module_root-grid__Ndknv","root-no-rows":"MRT_TableBody-module_root-no-rows__sck1s","root-virtualized":"MRT_TableBody-module_root-virtualized__B5Pkm","empty-row-tr-grid":"MRT_TableBody-module_empty-row-tr-grid__itf-D","empty-row-td-grid":"MRT_TableBody-module_empty-row-td-grid__8zVhY","empty-row-td-content":"MRT_TableBody-module_empty-row-td-content__KF5fT"};

const useMRT_Rows = (table, pinnedRowIds = []) => {
    const { getBottomRows, getCenterRows, getPrePaginationRowModel, getRowModel, getState, getTopRows, options: { enableGlobalFilterRankedResults, enablePagination, enableRowPinning, manualExpanding, manualFiltering, manualGrouping, manualPagination, manualSorting, rowPinningDisplayMode, }, } = table;
    const { expanded, globalFilter, pagination, rowPinning, sorting } = getState();
    const shouldRankRows = react.useMemo(() => getCanRankRows(table) &&
        !Object.values(sorting).some(Boolean) &&
        globalFilter, [
        enableGlobalFilterRankedResults,
        expanded,
        globalFilter,
        manualExpanding,
        manualFiltering,
        manualGrouping,
        manualSorting,
        sorting,
    ]);
    const rows = react.useMemo(() => {
        let rows = [];
        if (!shouldRankRows) {
            rows =
                !enableRowPinning || (rowPinningDisplayMode === null || rowPinningDisplayMode === void 0 ? void 0 : rowPinningDisplayMode.includes('sticky'))
                    ? getRowModel().rows
                    : getCenterRows();
        }
        else {
            rows = getPrePaginationRowModel().rows.sort((a, b) => rankGlobalFuzzy(a, b));
            if (enablePagination && !manualPagination) {
                const start = pagination.pageIndex * pagination.pageSize;
                rows = rows.slice(start, start + pagination.pageSize);
            }
        }
        if (enableRowPinning && (rowPinningDisplayMode === null || rowPinningDisplayMode === void 0 ? void 0 : rowPinningDisplayMode.includes('sticky'))) {
            rows = [
                ...getTopRows().filter((row) => !pinnedRowIds.includes(row.id)),
                ...rows,
                ...getBottomRows().filter((row) => !pinnedRowIds.includes(row.id)),
            ];
        }
        return rows;
    }, [
        shouldRankRows,
        shouldRankRows ? getPrePaginationRowModel().rows : getRowModel().rows,
        pagination.pageIndex,
        pagination.pageSize,
        rowPinning,
    ]);
    return rows;
};

const useMRT_RowVirtualizer = (table, rows) => {
    var _a;
    const { getRowModel, getState, options: { enableRowVirtualization, rowVirtualizerInstanceRef, rowVirtualizerOptions, }, refs: { tableContainerRef }, } = table;
    const { density, draggingRow } = getState();
    const rowVirtualizerProps = parseFromValuesOrFunc(rowVirtualizerOptions, {
        table,
    });
    const rowVirtualizer = enableRowVirtualization
        ? reactVirtual.useVirtualizer(Object.assign({ count: (_a = rows === null || rows === void 0 ? void 0 : rows.length) !== null && _a !== void 0 ? _a : getRowModel().rows.length, estimateSize: () => density === 'xs' ? 42.7 : density === 'md' ? 54.7 : 70.7, getScrollElement: () => tableContainerRef.current, measureElement: typeof window !== 'undefined' &&
                navigator.userAgent.indexOf('Firefox') === -1
                ? (element) => element === null || element === void 0 ? void 0 : element.getBoundingClientRect().height
                : undefined, overscan: 4, rangeExtractor: react.useCallback((range) => {
                var _a;
                return extraIndexRangeExtractor(range, (_a = draggingRow === null || draggingRow === void 0 ? void 0 : draggingRow.index) !== null && _a !== void 0 ? _a : 0);
            }, [draggingRow]) }, rowVirtualizerProps))
        : undefined;
    if (rowVirtualizer) {
        const virtualRows = rowVirtualizer.getVirtualItems();
        rowVirtualizer.virtualRows = virtualRows;
        if (rowVirtualizerInstanceRef) {
            //@ts-ignore
            rowVirtualizerInstanceRef.current = rowVirtualizer;
        }
    }
    return rowVirtualizer;
};

const MRT_TableBody = ({ columnVirtualizer, enableHover, isStriped, table, }) => {
    var _a, _b, _c, _d, _e;
    const { getBottomRows, getTopRows, getIsSomeRowsPinned, getRowModel, getState, options: { createDisplayMode, layoutMode, localization, mantineTableBodyProps, memoMode, renderEmptyRowsFallback, rowPinningDisplayMode, enableStickyFooter, enableStickyHeader, }, refs: { tablePaperRef, tableHeadRef, tableFooterRef }, } = table;
    const { creatingRow, columnFilters, globalFilter, rowPinning, isFullScreen } = getState();
    const tableBodyProps = parseFromValuesOrFunc(mantineTableBodyProps, {
        table,
    });
    const tableHeadHeight = ((enableStickyHeader || isFullScreen) &&
        ((_a = tableHeadRef.current) === null || _a === void 0 ? void 0 : _a.clientHeight)) ||
        0;
    const tableFooterHeight = (enableStickyFooter && ((_b = tableFooterRef.current) === null || _b === void 0 ? void 0 : _b.clientHeight)) || 0;
    const pinnedRowIds = react.useMemo(() => {
        var _a, _b;
        if (!((_a = rowPinning.bottom) === null || _a === void 0 ? void 0 : _a.length) && !((_b = rowPinning.top) === null || _b === void 0 ? void 0 : _b.length))
            return [];
        return getRowModel()
            .rows.filter((row) => row.getIsPinned())
            .map((r) => r.id);
    }, [rowPinning, getRowModel().rows]);
    const rows = useMRT_Rows(table, pinnedRowIds);
    const rowVirtualizer = useMRT_RowVirtualizer(table, rows);
    const { virtualRows } = rowVirtualizer !== null && rowVirtualizer !== void 0 ? rowVirtualizer : {};
    const commonRowProps = {
        columnVirtualizer,
        numRows: rows.length,
        table,
    };
    const CreatingRow = creatingRow && createDisplayMode === 'row' && (jsxRuntime.jsx(MRT_TableBodyRow, Object.assign({}, commonRowProps, { row: creatingRow, rowIndex: -1 })));
    return (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [!(rowPinningDisplayMode === null || rowPinningDisplayMode === void 0 ? void 0 : rowPinningDisplayMode.includes('sticky')) &&
                getIsSomeRowsPinned('top') && (jsxRuntime.jsx(core.TableTbody, Object.assign({}, tableBodyProps, { style: (theme) => (Object.assign({ display: (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith('grid')) ? 'grid' : undefined, position: 'sticky', top: tableHeadHeight - 1, zIndex: 1 }, parseFromValuesOrFunc(tableBodyProps === null || tableBodyProps === void 0 ? void 0 : tableBodyProps.style, theme))), children: getTopRows().map((row, rowIndex) => {
                    const props = Object.assign(Object.assign({}, commonRowProps), { row,
                        rowIndex });
                    return memoMode === 'rows' ? (jsxRuntime.jsx(Memo_MRT_TableBodyRow, Object.assign({}, props), row.id)) : (jsxRuntime.jsx(MRT_TableBodyRow, Object.assign({}, props), row.id));
                }) }))), rowVirtualizer && CreatingRow && (jsxRuntime.jsx(core.TableTbody, Object.assign({}, tableBodyProps, { style: (theme) => (Object.assign({ display: (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith('grid')) ? 'grid' : undefined }, parseFromValuesOrFunc(tableBodyProps === null || tableBodyProps === void 0 ? void 0 : tableBodyProps.style, theme))), children: CreatingRow }))), jsxRuntime.jsxs(core.TableTbody, Object.assign({}, tableBodyProps, { className: clsx(classes$y.root, (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith('grid')) && classes$y['root-grid'], !rows.length && classes$y['root-no-rows'], rowVirtualizer && classes$y['root-virtualized'], tableBodyProps === null || tableBodyProps === void 0 ? void 0 : tableBodyProps.className), __vars: Object.assign({ '--mrt-table-body-height': rowVirtualizer
                        ? `${rowVirtualizer.getTotalSize()}px`
                        : undefined }, tableBodyProps === null || tableBodyProps === void 0 ? void 0 : tableBodyProps.__vars), children: [!rowVirtualizer && CreatingRow, (_c = tableBodyProps === null || tableBodyProps === void 0 ? void 0 : tableBodyProps.children) !== null && _c !== void 0 ? _c : (!rows.length && !CreatingRow ? (jsxRuntime.jsx("tr", { className: clsx('mrt-table-body-row', (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith('grid')) && classes$y['empty-row-tr-grid']), children: jsxRuntime.jsx("td", { colSpan: table.getVisibleLeafColumns().length, className: clsx('mrt-table-body-cell', (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith('grid')) &&
                                classes$y['empty-row-td-grid']), children: (_d = renderEmptyRowsFallback === null || renderEmptyRowsFallback === void 0 ? void 0 : renderEmptyRowsFallback({ table })) !== null && _d !== void 0 ? _d : (jsxRuntime.jsx(core.Text, { className: clsx(classes$y['empty-row-td-content']), __vars: {
                                    '--mrt-paper-width': `${(_e = tablePaperRef.current) === null || _e === void 0 ? void 0 : _e.clientWidth}`,
                                }, children: globalFilter || columnFilters.length
                                    ? localization.noResultsFound
                                    : localization.noRecordsToDisplay })) }) })) : (jsxRuntime.jsx(jsxRuntime.Fragment, { children: (virtualRows !== null && virtualRows !== void 0 ? virtualRows : rows).map((rowOrVirtualRow, rowIndex) => {
                            const row = rowVirtualizer
                                ? rows[rowOrVirtualRow.index]
                                : rowOrVirtualRow;
                            const props = Object.assign(Object.assign({}, commonRowProps), { enableHover,
                                isStriped, measureElement: rowVirtualizer === null || rowVirtualizer === void 0 ? void 0 : rowVirtualizer.measureElement, pinnedRowIds,
                                row, rowIndex: rowVirtualizer ? rowOrVirtualRow.index : rowIndex, virtualRow: rowVirtualizer
                                    ? rowOrVirtualRow
                                    : undefined });
                            const key = `${row.id}-${row.index}`;
                            return memoMode === 'rows' ? (jsxRuntime.jsx(Memo_MRT_TableBodyRow, Object.assign({}, props), key)) : (jsxRuntime.jsx(MRT_TableBodyRow, Object.assign({}, props), key));
                        }) })))] })), !(rowPinningDisplayMode === null || rowPinningDisplayMode === void 0 ? void 0 : rowPinningDisplayMode.includes('sticky')) &&
                getIsSomeRowsPinned('bottom') && (jsxRuntime.jsx(core.TableTbody, Object.assign({}, tableBodyProps, { style: (theme) => (Object.assign({ bottom: tableFooterHeight - 1, display: (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith('grid')) ? 'grid' : undefined, position: 'sticky', zIndex: 1 }, parseFromValuesOrFunc(tableBodyProps === null || tableBodyProps === void 0 ? void 0 : tableBodyProps.style, theme))), children: getBottomRows().map((row, rowIndex) => {
                    const props = Object.assign(Object.assign({}, commonRowProps), { row,
                        rowIndex });
                    return memoMode === 'rows' ? (jsxRuntime.jsx(Memo_MRT_TableBodyRow, Object.assign({}, props), row.id)) : (jsxRuntime.jsx(MRT_TableBodyRow, Object.assign({}, props), row.id));
                }) })))] }));
};
const Memo_MRT_TableBody = react.memo(MRT_TableBody, (prev, next) => prev.table.options.data === next.table.options.data);

var classes$x = {"grab-icon":"MRT_GrabHandleButton-module_grab-icon__9Yqqt"};

const MRT_GrabHandleButton = ({ actionIconProps, onDragEnd, onDragStart, table: { options: { icons: { IconGripHorizontal }, localization: { move }, }, }, }) => {
    var _a, _b;
    return (jsxRuntime.jsx(core.Tooltip, { withinPortal: true, openDelay: 1000, label: (_a = actionIconProps === null || actionIconProps === void 0 ? void 0 : actionIconProps.title) !== null && _a !== void 0 ? _a : move, children: jsxRuntime.jsx(core.ActionIcon, Object.assign({ "aria-label": (_b = actionIconProps === null || actionIconProps === void 0 ? void 0 : actionIconProps.title) !== null && _b !== void 0 ? _b : move, draggable: true }, actionIconProps, { onClick: (e) => {
                var _a;
                e.stopPropagation();
                (_a = actionIconProps === null || actionIconProps === void 0 ? void 0 : actionIconProps.onClick) === null || _a === void 0 ? void 0 : _a.call(actionIconProps, e);
            }, color: "gray", variant: "transparent", onDragStart: onDragStart, onDragEnd: onDragEnd, className: clsx('mrt-grab-handle-button', classes$x['grab-icon'], actionIconProps === null || actionIconProps === void 0 ? void 0 : actionIconProps.className), title: undefined, children: jsxRuntime.jsx(IconGripHorizontal, {}) })) }));
};

const MRT_TableBodyRowGrabHandle = ({ row, rowRef, table, }) => {
    const { options: { mantineRowDragHandleProps }, } = table;
    const actionIconProps = parseFromValuesOrFunc(mantineRowDragHandleProps, {
        row,
        table,
    });
    const handleDragStart = (event) => {
        var _a;
        (_a = actionIconProps === null || actionIconProps === void 0 ? void 0 : actionIconProps.onDragStart) === null || _a === void 0 ? void 0 : _a.call(actionIconProps, event);
        event.dataTransfer.setDragImage(rowRef.current, 0, 0);
        table.setDraggingRow(row);
    };
    const handleDragEnd = (event) => {
        var _a;
        (_a = actionIconProps === null || actionIconProps === void 0 ? void 0 : actionIconProps.onDragEnd) === null || _a === void 0 ? void 0 : _a.call(actionIconProps, event);
        table.setDraggingRow(null);
        table.setHoveredRow(null);
    };
    return (jsxRuntime.jsx(MRT_GrabHandleButton, { actionIconProps: actionIconProps, onDragStart: handleDragStart, onDragEnd: handleDragEnd, table: table }));
};

var classes$w = {"root":"MRT_ExpandAllButton-module_root__QGaUK","chevron":"MRT_ExpandAllButton-module_chevron__xIAbV","up":"MRT_ExpandAllButton-module_up__ropcE","right":"MRT_ExpandAllButton-module_right__sj9hk"};

const MRT_ExpandAllButton = ({ table, }) => {
    var _a, _b;
    const { getIsAllRowsExpanded, getIsSomeRowsExpanded, getCanSomeRowsExpand, getState, options: { icons: { IconChevronsDown }, localization, mantineExpandAllButtonProps, renderDetailPanel, }, toggleAllRowsExpanded, } = table;
    const { density, isLoading } = getState();
    const actionIconProps = parseFromValuesOrFunc(mantineExpandAllButtonProps, {
        table,
    });
    const isAllRowsExpanded = getIsAllRowsExpanded();
    return (jsxRuntime.jsx(core.Tooltip, { withinPortal: true, openDelay: 1000, label: ((_a = actionIconProps === null || actionIconProps === void 0 ? void 0 : actionIconProps.title) !== null && _a !== void 0 ? _a : isAllRowsExpanded)
            ? localization.collapseAll
            : localization.expandAll, children: jsxRuntime.jsx(core.ActionIcon, Object.assign({ "aria-label": localization.expandAll, color: "gray", variant: "subtle" }, actionIconProps, { disabled: isLoading || (!renderDetailPanel && !getCanSomeRowsExpand()), onClick: () => toggleAllRowsExpanded(!isAllRowsExpanded), className: clsx('mrt-expand-all-button', classes$w.root, actionIconProps === null || actionIconProps === void 0 ? void 0 : actionIconProps.className, density), title: undefined, children: (_b = actionIconProps === null || actionIconProps === void 0 ? void 0 : actionIconProps.children) !== null && _b !== void 0 ? _b : (jsxRuntime.jsx(IconChevronsDown, { className: clsx(classes$w.chevron, isAllRowsExpanded
                    ? classes$w.up
                    : getIsSomeRowsExpanded()
                        ? classes$w.right
                        : undefined) })) })) }));
};

var classes$v = {"root":"MRT_ExpandButton-module_root__bKd9j","chevron":"MRT_ExpandButton-module_chevron__ZwDsP","right":"MRT_ExpandButton-module_right__pR-Xm","up":"MRT_ExpandButton-module_up__DpQ1K"};

const MRT_ExpandButton = ({ row, table, }) => {
    var _a, _b;
    const { options: { icons: { IconChevronDown }, localization, mantineExpandButtonProps, renderDetailPanel, }, } = table;
    const actionIconProps = parseFromValuesOrFunc(mantineExpandButtonProps, {
        table,
        row,
    });
    const canExpand = row.getCanExpand();
    const isExpanded = row.getIsExpanded();
    const handleToggleExpand = (event) => {
        var _a;
        event.stopPropagation();
        row.toggleExpanded();
        (_a = actionIconProps === null || actionIconProps === void 0 ? void 0 : actionIconProps.onClick) === null || _a === void 0 ? void 0 : _a.call(actionIconProps, event);
    };
    return (jsxRuntime.jsx(core.Tooltip, { withinPortal: true, disabled: !canExpand && !renderDetailPanel, openDelay: 1000, label: ((_a = actionIconProps === null || actionIconProps === void 0 ? void 0 : actionIconProps.title) !== null && _a !== void 0 ? _a : isExpanded)
            ? localization.collapse
            : localization.expand, children: jsxRuntime.jsx(core.ActionIcon, Object.assign({ "aria-label": localization.expand, color: "gray", disabled: !canExpand && !renderDetailPanel, variant: "subtle" }, actionIconProps, { onClick: handleToggleExpand, className: clsx('mrt-expand-button', classes$v.root, actionIconProps === null || actionIconProps === void 0 ? void 0 : actionIconProps.className), title: undefined, children: (_b = actionIconProps === null || actionIconProps === void 0 ? void 0 : actionIconProps.children) !== null && _b !== void 0 ? _b : (jsxRuntime.jsx(IconChevronDown, { className: clsx('mrt-expand-button-chevron', classes$v.chevron, !canExpand && !renderDetailPanel
                    ? classes$v.right
                    : isExpanded
                        ? classes$v.up
                        : undefined) })) })) }));
};

const MRT_RowActionMenu = ({ handleEdit, row, table, }) => {
    const { options: { editDisplayMode, enableEditing, icons: { IconEdit, IconDots }, localization, positionActionsColumn, renderRowActionMenuItems, }, } = table;
    return (jsxRuntime.jsxs(core.Menu, { position: positionActionsColumn === 'first'
            ? 'bottom-start'
            : positionActionsColumn === 'last'
                ? 'bottom-end'
                : undefined, closeOnItemClick: true, withinPortal: true, children: [jsxRuntime.jsx(core.Tooltip, { withinPortal: true, openDelay: 1000, label: localization.rowActions, children: jsxRuntime.jsx(core.Menu.Target, { children: jsxRuntime.jsx(core.ActionIcon, { "aria-label": localization.rowActions, color: "gray", onClick: (event) => event.stopPropagation(), size: "sm", variant: "subtle", children: jsxRuntime.jsx(IconDots, {}) }) }) }), jsxRuntime.jsxs(core.Menu.Dropdown, { onClick: (event) => event.stopPropagation(), children: [enableEditing && editDisplayMode !== 'table' && (jsxRuntime.jsx(core.Menu.Item, { leftSection: jsxRuntime.jsx(IconEdit, {}), onClick: handleEdit, children: localization.edit })), renderRowActionMenuItems === null || renderRowActionMenuItems === void 0 ? void 0 : renderRowActionMenuItems({
                        row,
                        table,
                    })] })] }));
};

var classes$u = {"root":"MRT_EditActionButtons-module_root__n1yv9"};

const MRT_EditActionButtons = ({ row, table, variant = 'icon', }) => {
    const { getState, options: { icons: { IconCircleX, IconDeviceFloppy }, localization, onCreatingRowCancel, onCreatingRowSave, onEditingRowSave, onEditingRowCancel, }, refs: { editInputRefs }, setCreatingRow, setEditingRow, } = table;
    const { creatingRow, editingRow, isSaving } = getState();
    const isCreating = (creatingRow === null || creatingRow === void 0 ? void 0 : creatingRow.id) === row.id;
    const isEditing = (editingRow === null || editingRow === void 0 ? void 0 : editingRow.id) === row.id;
    const handleCancel = () => {
        if (isCreating) {
            onCreatingRowCancel === null || onCreatingRowCancel === void 0 ? void 0 : onCreatingRowCancel({ row, table });
            setCreatingRow(null);
        }
        else if (isEditing) {
            onEditingRowCancel === null || onEditingRowCancel === void 0 ? void 0 : onEditingRowCancel({ row, table });
            setEditingRow(null);
        }
        row._valuesCache = {}; //reset values cache
    };
    const handleSubmitRow = () => {
        var _a;
        //look for auto-filled input values
        (_a = Object.values(editInputRefs === null || editInputRefs === void 0 ? void 0 : editInputRefs.current)
            .filter((inputRef) => { var _a, _b; return row.id === ((_b = (_a = inputRef === null || inputRef === void 0 ? void 0 : inputRef.name) === null || _a === void 0 ? void 0 : _a.split('_')) === null || _b === void 0 ? void 0 : _b[0]); })) === null || _a === void 0 ? void 0 : _a.forEach((input) => {
            if (input.value !== undefined &&
                Object.hasOwn(row === null || row === void 0 ? void 0 : row._valuesCache, input.name)) {
                // @ts-ignore
                row._valuesCache[input.name] = input.value;
            }
        });
        if (isCreating)
            onCreatingRowSave === null || onCreatingRowSave === void 0 ? void 0 : onCreatingRowSave({
                exitCreatingMode: () => setCreatingRow(null),
                row,
                table,
                values: row._valuesCache,
            });
        else if (isEditing) {
            onEditingRowSave === null || onEditingRowSave === void 0 ? void 0 : onEditingRowSave({
                exitEditingMode: () => setEditingRow(null),
                row,
                table,
                values: row === null || row === void 0 ? void 0 : row._valuesCache,
            });
        }
    };
    return (jsxRuntime.jsx(core.Box, { onClick: (e) => e.stopPropagation(), className: clsx('mrt-edit-action-buttons', classes$u.root), children: variant === 'icon' ? (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx(core.Tooltip, { withinPortal: true, label: localization.cancel, children: jsxRuntime.jsx(core.ActionIcon, { color: "red", "aria-label": localization.cancel, onClick: handleCancel, variant: "subtle", children: jsxRuntime.jsx(IconCircleX, {}) }) }), jsxRuntime.jsx(core.Tooltip, { withinPortal: true, label: localization.save, children: jsxRuntime.jsx(core.ActionIcon, { "aria-label": localization.save, color: "blue", onClick: handleSubmitRow, loading: isSaving, variant: "subtle", children: jsxRuntime.jsx(IconDeviceFloppy, {}) }) })] })) : (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx(core.Button, { onClick: handleCancel, variant: "subtle", children: localization.cancel }), jsxRuntime.jsx(core.Button, { onClick: handleSubmitRow, variant: "filled", loading: isSaving, children: localization.save })] })) }));
};

const MRT_ToggleRowActionMenuButton = ({ cell, row, table, }) => {
    const { getState, options: { createDisplayMode, editDisplayMode, enableEditing, icons: { IconEdit }, localization: { edit }, renderRowActionMenuItems, renderRowActions, }, setEditingRow, } = table;
    const { creatingRow, editingRow } = getState();
    const isCreating = (creatingRow === null || creatingRow === void 0 ? void 0 : creatingRow.id) === row.id;
    const isEditing = (editingRow === null || editingRow === void 0 ? void 0 : editingRow.id) === row.id;
    const handleStartEditMode = (event) => {
        event.stopPropagation();
        setEditingRow(Object.assign({}, row));
    };
    const showEditActionButtons = (isCreating && createDisplayMode === 'row') ||
        (isEditing && editDisplayMode === 'row');
    return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: renderRowActions && !showEditActionButtons ? (renderRowActions({ cell, row, table })) : showEditActionButtons ? (jsxRuntime.jsx(MRT_EditActionButtons, { row: row, table: table })) : !renderRowActionMenuItems &&
            parseFromValuesOrFunc(enableEditing, row) ? (jsxRuntime.jsx(core.Tooltip, { withinPortal: true, openDelay: 1000, position: "right", label: edit, children: jsxRuntime.jsx(core.ActionIcon, { "aria-label": edit, disabled: !!editingRow && editingRow.id !== row.id, onClick: handleStartEditMode, size: "md", variant: "default", children: jsxRuntime.jsx(IconEdit, {}) }) })) : renderRowActionMenuItems ? (jsxRuntime.jsx(MRT_RowActionMenu, { handleEdit: handleStartEditMode, row: row, table: table })) : null }));
};

const MRT_SelectCheckbox = ({ row, selectAll, table, staticRowIndex, }) => {
    var _a;
    const { getState, options: { enableMultiRowSelection, localization, mantineSelectAllCheckboxProps, mantineSelectCheckboxProps, selectAllMode, selectDisplayMode, rowPinningDisplayMode, enableRowPinning, }, } = table;
    const { density, isLoading } = getState();
    const checkboxProps = !row
        ? parseFromValuesOrFunc(mantineSelectAllCheckboxProps, { table })
        : parseFromValuesOrFunc(mantineSelectCheckboxProps, {
            row,
            table,
            staticRowIndex,
        });
    const isStickySelection = enableRowPinning && (rowPinningDisplayMode === null || rowPinningDisplayMode === void 0 ? void 0 : rowPinningDisplayMode.includes('select'));
    const allRowsSelected = selectAll
        ? selectAllMode === 'page'
            ? table.getIsAllPageRowsSelected()
            : table.getIsAllRowsSelected()
        : undefined;
    const onSelectionChange = (event, row) => {
        var _a;
        if (row.getIsAllSubRowsSelected()) {
            (_a = row.subRows) === null || _a === void 0 ? void 0 : _a.forEach((r) => r.toggleSelected(false));
        }
        row.getToggleSelectedHandler()(event);
        if (isStickySelection) {
            row.pin(!row.getIsPinned() && event.target.checked
                ? (rowPinningDisplayMode === null || rowPinningDisplayMode === void 0 ? void 0 : rowPinningDisplayMode.includes('bottom'))
                    ? 'bottom'
                    : 'top'
                : false);
        }
    };
    const onSelectAllChange = (event) => {
        selectAllMode === 'all'
            ? table.getToggleAllRowsSelectedHandler()(event)
            : table.getToggleAllPageRowsSelectedHandler()(event);
        if (isStickySelection) {
            table.setRowPinning({ bottom: [], top: [] });
        }
    };
    const commonProps = Object.assign(Object.assign({ 'aria-label': selectAll
            ? localization.toggleSelectAll
            : localization.toggleSelectRow, checked: selectAll
            ? allRowsSelected
            : (row === null || row === void 0 ? void 0 : row.getIsSelected()) || (row === null || row === void 0 ? void 0 : row.getIsAllSubRowsSelected()), disabled: isLoading || (row && !row.getCanSelect()), onChange: (event) => {
            event.stopPropagation();
            row ? onSelectionChange(event, row) : onSelectAllChange(event);
        }, size: density === 'xs' ? 'sm' : 'md' }, checkboxProps), { onClick: (e) => {
            var _a;
            e.stopPropagation();
            (_a = checkboxProps === null || checkboxProps === void 0 ? void 0 : checkboxProps.onClick) === null || _a === void 0 ? void 0 : _a.call(checkboxProps, e);
        }, title: undefined });
    return (jsxRuntime.jsx(core.Tooltip, { withinPortal: true, openDelay: 1000, label: (_a = checkboxProps === null || checkboxProps === void 0 ? void 0 : checkboxProps.title) !== null && _a !== void 0 ? _a : (selectAll
            ? localization.toggleSelectAll
            : localization.toggleSelectRow), children: jsxRuntime.jsx("span", { children: selectDisplayMode === 'switch' ? (jsxRuntime.jsx(core.Switch, Object.assign({}, commonProps))) : selectDisplayMode === 'radio' ||
                enableMultiRowSelection === false ? (jsxRuntime.jsx(core.Radio, Object.assign({}, commonProps))) : (jsxRuntime.jsx(core.Checkbox, Object.assign({ indeterminate: selectAll
                    ? table.getIsSomeRowsSelected() && !allRowsSelected
                    : row === null || row === void 0 ? void 0 : row.getIsSomeSelected() }, commonProps))) }) }));
};

const useMRT_DisplayColumns = (params) => {
    var _a, _b, _c, _d;
    const { columnOrder, creatingRow, grouping, tableOptions } = params;
    const order = (_b = (_a = tableOptions.state) === null || _a === void 0 ? void 0 : _a.columnOrder) !== null && _b !== void 0 ? _b : columnOrder;
    return react.useMemo(() => [
        makeRowPinColumn,
        makeRowDragColumn,
        makeRowActionsColumn,
        makeRowExpandColumn,
        makeRowSelectColumn,
        makeRowNumbersColumn,
        makeSpacerColumn,
    ]
        .map((makeCol) => makeCol(params, order))
        .filter(Boolean), [
        columnOrder,
        creatingRow,
        grouping,
        tableOptions.displayColumnDefOptions,
        tableOptions.editDisplayMode,
        tableOptions.enableColumnDragging,
        tableOptions.enableColumnFilterModes,
        tableOptions.enableColumnOrdering,
        tableOptions.enableEditing,
        tableOptions.enableExpandAll,
        tableOptions.enableExpanding,
        tableOptions.enableGrouping,
        tableOptions.enableRowActions,
        tableOptions.enableRowDragging,
        tableOptions.enableRowNumbers,
        tableOptions.enableRowOrdering,
        tableOptions.enableRowSelection,
        tableOptions.enableSelectAll,
        tableOptions.groupedColumnMode,
        tableOptions.localization,
        tableOptions.positionActionsColumn,
        tableOptions.renderDetailPanel,
        tableOptions.renderRowActionMenuItems,
        tableOptions.renderRowActions,
        (_c = tableOptions.state) === null || _c === void 0 ? void 0 : _c.columnOrder,
        (_d = tableOptions.state) === null || _d === void 0 ? void 0 : _d.grouping,
    ]);
};
function defaultDisplayColumnProps({ defaultDisplayColumn, displayColumnDefOptions, localization, }, id, header, size = 60) {
    return Object.assign(Object.assign(Object.assign(Object.assign({}, defaultDisplayColumn), { header: header ? localization[header] : '', size }), displayColumnDefOptions === null || displayColumnDefOptions === void 0 ? void 0 : displayColumnDefOptions[id]), { id });
}
function makeRowPinColumn({ tableOptions }, order) {
    const id = 'mrt-row-pin';
    if (order.includes(id)) {
        return Object.assign({ Cell: ({ row, table }) => (jsxRuntime.jsx(MRT_TableBodyRowPinButton, { row: row, table: table })) }, defaultDisplayColumnProps(tableOptions, id, 'pin'));
    }
    return null;
}
function makeRowDragColumn({ tableOptions }, order) {
    const id = 'mrt-row-drag';
    if (order.includes(id)) {
        return Object.assign({ Cell: ({ row, rowRef, table }) => (jsxRuntime.jsx(MRT_TableBodyRowGrabHandle, { row: row, rowRef: rowRef, table: table })) }, defaultDisplayColumnProps(tableOptions, id, 'move'));
    }
    return null;
}
function makeRowActionsColumn({ creatingRow, tableOptions }, order) {
    const id = 'mrt-row-actions';
    if (order.includes(id) ||
        (creatingRow && tableOptions.createDisplayMode === 'row')) {
        return Object.assign({ Cell: ({ cell, row, table }) => (jsxRuntime.jsx(MRT_ToggleRowActionMenuButton, { cell: cell, row: row, table: table })) }, defaultDisplayColumnProps(tableOptions, id, 'actions'));
    }
    return null;
}
function makeRowExpandColumn({ grouping, tableOptions }, order) {
    var _a, _b, _c;
    const id = 'mrt-row-expand';
    if (order.includes(id) &&
        showExpandColumn(tableOptions, (_b = (_a = tableOptions.state) === null || _a === void 0 ? void 0 : _a.grouping) !== null && _b !== void 0 ? _b : grouping)) {
        return Object.assign({ Cell: ({ cell, column, row, table }) => {
                var _a, _b, _c;
                const expandButtonProps = { row, table };
                const subRowsLength = (_a = row.subRows) === null || _a === void 0 ? void 0 : _a.length;
                if (tableOptions.groupedColumnMode === 'remove' &&
                    row.groupingColumnId) {
                    return (jsxRuntime.jsxs(core.Flex, { align: "center", gap: "0.25rem", children: [jsxRuntime.jsx(MRT_ExpandButton, Object.assign({}, expandButtonProps)), jsxRuntime.jsx(core.Tooltip, { openDelay: 1000, position: "right", label: table.getColumn(row.groupingColumnId).columnDef.header, children: jsxRuntime.jsx("span", { children: row.groupingValue }) }), !!subRowsLength && jsxRuntime.jsxs("span", { children: ["(", subRowsLength, ")"] })] }));
                }
                else {
                    return (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx(MRT_ExpandButton, Object.assign({}, expandButtonProps)), (_c = (_b = column.columnDef).GroupedCell) === null || _c === void 0 ? void 0 : _c.call(_b, { cell, column, row, table })] }));
                }
            }, Header: tableOptions.enableExpandAll
                ? ({ table }) => {
                    return (jsxRuntime.jsxs(core.Flex, { align: "center", children: [jsxRuntime.jsx(MRT_ExpandAllButton, { table: table }), tableOptions.groupedColumnMode === 'remove' &&
                                grouping
                                    .map((groupedColumnId) => table.getColumn(groupedColumnId).columnDef.header)
                                    .join(', ')] }));
                }
                : undefined }, defaultDisplayColumnProps(tableOptions, id, 'expand', tableOptions.groupedColumnMode === 'remove'
            ? (_c = tableOptions === null || tableOptions === void 0 ? void 0 : tableOptions.defaultColumn) === null || _c === void 0 ? void 0 : _c.size
            : 60));
    }
    return null;
}
function makeRowSelectColumn({ tableOptions }, order) {
    const id = 'mrt-row-select';
    if (order.includes(id)) {
        return Object.assign({ Cell: ({ row, staticRowIndex, table }) => (jsxRuntime.jsx(MRT_SelectCheckbox, { row: row, staticRowIndex: staticRowIndex, table: table })), Header: tableOptions.enableSelectAll && tableOptions.enableMultiRowSelection
                ? ({ table }) => jsxRuntime.jsx(MRT_SelectCheckbox, { selectAll: true, table: table })
                : undefined }, defaultDisplayColumnProps(tableOptions, id, 'select'));
    }
    return null;
}
function makeRowNumbersColumn({ tableOptions }, order) {
    const id = 'mrt-row-numbers';
    if (order.includes(id) || tableOptions.enableRowNumbers)
        return Object.assign({ Cell: ({ row, staticRowIndex }) => {
                var _a;
                return ((_a = (tableOptions.rowNumberDisplayMode === 'static'
                    ? staticRowIndex
                    : row.index)) !== null && _a !== void 0 ? _a : 0) + 1;
            }, Header: () => tableOptions.localization.rowNumber }, defaultDisplayColumnProps(tableOptions, id, 'rowNumbers'));
    return null;
}
const blankColProps = {
    children: null,
    style: {
        flex: '1 0 auto',
        minWidth: 0,
        padding: 0,
        width: 0,
    },
};
function makeSpacerColumn({ tableOptions }, order) {
    const id = 'mrt-row-spacer';
    if (order.includes(id)) {
        return Object.assign(Object.assign(Object.assign({}, defaultDisplayColumnProps(tableOptions, id, undefined, 0)), MRT_DefaultDisplayColumn), { mantineTableBodyCellProps: blankColProps, mantineTableFooterCellProps: blankColProps, mantineTableHeadCellProps: blankColProps });
    }
    return null;
}

const useMRT_Effects = (table) => {
    const { getIsSomeRowsPinned, getState, options: { enablePagination, enableRowPinning, rowCount }, } = table;
    const { density, globalFilter, isFullScreen, isLoading, pagination, showSkeletons, sorting, } = getState();
    const rerender = react.useReducer(() => ({}), {})[1];
    const isMounted = react.useRef(false);
    const initialBodyHeight = react.useRef();
    const previousTop = react.useRef();
    react.useEffect(() => {
        if (typeof window !== 'undefined') {
            initialBodyHeight.current = document.body.style.height;
        }
    }, []);
    react.useEffect(() => {
        if (isMounted && typeof window !== 'undefined') {
            if (isFullScreen) {
                previousTop.current = document.body.getBoundingClientRect().top; //save scroll position
                document.body.style.height = '100vh'; //hide page scrollbars when table is in full screen mode
            }
            else {
                document.body.style.height = initialBodyHeight.current;
                if (!previousTop.current)
                    return;
                //restore scroll position
                window.scrollTo({
                    behavior: 'instant',
                    top: -1 * previousTop.current,
                });
            }
        }
        isMounted.current = true;
    }, [isFullScreen]);
    //if page index is out of bounds, set it to the last page
    react.useEffect(() => {
        if (!enablePagination || isLoading || showSkeletons)
            return;
        const { pageIndex, pageSize } = pagination;
        const totalRowCount = rowCount !== null && rowCount !== void 0 ? rowCount : table.getPrePaginationRowModel().rows.length;
        const firstVisibleRowIndex = pageIndex * pageSize;
        if (firstVisibleRowIndex > totalRowCount) {
            table.setPageIndex(Math.floor(totalRowCount / pageSize));
        }
    }, [rowCount, table.getPrePaginationRowModel().rows.length]);
    //turn off sort when global filter is looking for ranked results
    const appliedSort = react.useRef(sorting);
    react.useEffect(() => {
        if (sorting.length) {
            appliedSort.current = sorting;
        }
    }, [sorting]);
    react.useEffect(() => {
        if (!getCanRankRows(table))
            return;
        if (globalFilter) {
            table.setSorting([]);
        }
        else {
            table.setSorting(() => appliedSort.current || []);
        }
    }, [globalFilter]);
    react.useEffect(() => {
        if (enableRowPinning && getIsSomeRowsPinned()) {
            setTimeout(() => {
                rerender();
            }, 150);
        }
    }, [density]);
};

const useMRT_TableInstance = (tableOptions) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10;
    const bottomToolbarRef = react.useRef(null);
    const editInputRefs = react.useRef({});
    const filterInputRefs = react.useRef({});
    const searchInputRef = react.useRef(null);
    const tableContainerRef = react.useRef(null);
    const tableHeadCellRefs = react.useRef({});
    const tablePaperRef = react.useRef(null);
    const topToolbarRef = react.useRef(null);
    const tableHeadRef = react.useRef(null);
    const tableFooterRef = react.useRef(null);
    const initialState = react.useMemo(() => {
        var _a, _b, _c;
        const initState = (_a = tableOptions.initialState) !== null && _a !== void 0 ? _a : {};
        initState.columnOrder =
            (_b = initState.columnOrder) !== null && _b !== void 0 ? _b : getDefaultColumnOrderIds(tableOptions);
        initState.globalFilterFn = (_c = tableOptions.globalFilterFn) !== null && _c !== void 0 ? _c : 'fuzzy';
        return initState;
    }, []);
    const [creatingRow, _setCreatingRow] = react.useState((_a = initialState.creatingRow) !== null && _a !== void 0 ? _a : null);
    const [columnFilterFns, setColumnFilterFns] = react.useState(() => Object.assign({}, ...getAllLeafColumnDefs(tableOptions.columns).map((col) => {
        var _a, _b, _c, _d;
        return ({
            [getColumnId(col)]: col.filterFn instanceof Function
                ? (_a = col.filterFn.name) !== null && _a !== void 0 ? _a : 'custom'
                : (_d = (_b = col.filterFn) !== null && _b !== void 0 ? _b : (_c = initialState === null || initialState === void 0 ? void 0 : initialState.columnFilterFns) === null || _c === void 0 ? void 0 : _c[getColumnId(col)]) !== null && _d !== void 0 ? _d : getDefaultColumnFilterFn(col),
        });
    })));
    const [columnOrder, setColumnOrder] = react.useState((_b = initialState.columnOrder) !== null && _b !== void 0 ? _b : []);
    const [density, setDensity] = react.useState((_c = initialState === null || initialState === void 0 ? void 0 : initialState.density) !== null && _c !== void 0 ? _c : 'md');
    const [draggingColumn, setDraggingColumn] = react.useState((_d = initialState.draggingColumn) !== null && _d !== void 0 ? _d : null);
    const [draggingRow, setDraggingRow] = react.useState((_e = initialState.draggingRow) !== null && _e !== void 0 ? _e : null);
    const [editingCell, setEditingCell] = react.useState((_f = initialState.editingCell) !== null && _f !== void 0 ? _f : null);
    const [editingRow, setEditingRow] = react.useState((_g = initialState.editingRow) !== null && _g !== void 0 ? _g : null);
    const [globalFilterFn, setGlobalFilterFn] = react.useState((_h = initialState.globalFilterFn) !== null && _h !== void 0 ? _h : 'fuzzy');
    const [grouping, setGrouping] = react.useState((_j = initialState.grouping) !== null && _j !== void 0 ? _j : []);
    const [hoveredColumn, setHoveredColumn] = react.useState((_k = initialState.hoveredColumn) !== null && _k !== void 0 ? _k : null);
    const [hoveredRow, setHoveredRow] = react.useState((_l = initialState.hoveredRow) !== null && _l !== void 0 ? _l : null);
    const [isFullScreen, setIsFullScreen] = react.useState((_m = initialState === null || initialState === void 0 ? void 0 : initialState.isFullScreen) !== null && _m !== void 0 ? _m : false);
    const [showAlertBanner, setShowAlertBanner] = react.useState((_p = (_o = tableOptions.initialState) === null || _o === void 0 ? void 0 : _o.showAlertBanner) !== null && _p !== void 0 ? _p : false);
    const [showColumnFilters, setShowColumnFilters] = react.useState((_q = initialState === null || initialState === void 0 ? void 0 : initialState.showColumnFilters) !== null && _q !== void 0 ? _q : false);
    const [showGlobalFilter, setShowGlobalFilter] = react.useState((_r = initialState === null || initialState === void 0 ? void 0 : initialState.showGlobalFilter) !== null && _r !== void 0 ? _r : false);
    const [showToolbarDropZone, setShowToolbarDropZone] = react.useState((_s = initialState === null || initialState === void 0 ? void 0 : initialState.showToolbarDropZone) !== null && _s !== void 0 ? _s : false);
    const displayColumns = useMRT_DisplayColumns({
        columnOrder,
        creatingRow,
        grouping,
        tableOptions,
    });
    const columnDefs = react.useMemo(() => {
        var _a, _b, _c;
        return prepareColumns({
            aggregationFns: tableOptions.aggregationFns,
            columnDefs: [...displayColumns, ...tableOptions.columns],
            columnFilterFns: (_b = (_a = tableOptions.state) === null || _a === void 0 ? void 0 : _a.columnFilterFns) !== null && _b !== void 0 ? _b : columnFilterFns,
            defaultDisplayColumn: (_c = tableOptions.defaultDisplayColumn) !== null && _c !== void 0 ? _c : {},
            filterFns: tableOptions.filterFns,
            sortingFns: tableOptions.sortingFns,
        });
    }, [
        columnFilterFns,
        displayColumns,
        tableOptions.columns,
        (_t = tableOptions.state) === null || _t === void 0 ? void 0 : _t.columnFilterFns,
    ]);
    const data = react.useMemo(() => {
        var _a, _b, _c, _d, _e;
        return (((_a = tableOptions.state) === null || _a === void 0 ? void 0 : _a.isLoading) || ((_b = tableOptions.state) === null || _b === void 0 ? void 0 : _b.showSkeletons)) &&
            !tableOptions.data.length
            ? [
                ...Array(((_d = (_c = tableOptions.state) === null || _c === void 0 ? void 0 : _c.pagination) === null || _d === void 0 ? void 0 : _d.pageSize) ||
                    ((_e = initialState === null || initialState === void 0 ? void 0 : initialState.pagination) === null || _e === void 0 ? void 0 : _e.pageSize) ||
                    10).fill(null),
            ].map(() => Object.assign({}, ...getAllLeafColumnDefs(tableOptions.columns).map((col) => ({
                [getColumnId(col)]: null,
            }))))
            : tableOptions.data;
    }, [
        tableOptions.data,
        (_u = tableOptions.state) === null || _u === void 0 ? void 0 : _u.isLoading,
        (_v = tableOptions.state) === null || _v === void 0 ? void 0 : _v.showSkeletons,
    ]);
    //@ts-ignore
    const table = reactTable.useReactTable(Object.assign(Object.assign({ getCoreRowModel: reactTable.getCoreRowModel(), getExpandedRowModel: tableOptions.enableExpanding || tableOptions.enableGrouping
            ? reactTable.getExpandedRowModel()
            : undefined, getFacetedMinMaxValues: tableOptions.enableFacetedValues
            ? reactTable.getFacetedMinMaxValues()
            : undefined, getFacetedRowModel: tableOptions.enableFacetedValues
            ? reactTable.getFacetedRowModel()
            : undefined, getFacetedUniqueValues: tableOptions.enableFacetedValues
            ? reactTable.getFacetedUniqueValues()
            : undefined, getFilteredRowModel: tableOptions.enableColumnFilters ||
            tableOptions.enableGlobalFilter ||
            tableOptions.enableFilters
            ? reactTable.getFilteredRowModel()
            : undefined, getGroupedRowModel: tableOptions.enableGrouping
            ? reactTable.getGroupedRowModel()
            : undefined, getPaginationRowModel: tableOptions.enablePagination
            ? reactTable.getPaginationRowModel()
            : undefined, getSortedRowModel: tableOptions.enableSorting
            ? reactTable.getSortedRowModel()
            : undefined, onColumnOrderChange: setColumnOrder, onGroupingChange: setGrouping, getSubRows: (row) => row === null || row === void 0 ? void 0 : row.subRows }, tableOptions), { 
        //@ts-ignore
        columns: columnDefs, data, globalFilterFn: (_w = tableOptions.filterFns) === null || _w === void 0 ? void 0 : _w[globalFilterFn !== null && globalFilterFn !== void 0 ? globalFilterFn : 'fuzzy'], initialState, state: Object.assign({ creatingRow,
            columnFilterFns,
            columnOrder,
            density,
            draggingColumn,
            draggingRow,
            editingCell,
            editingRow,
            globalFilterFn,
            grouping,
            hoveredColumn,
            hoveredRow,
            isFullScreen,
            showAlertBanner,
            showColumnFilters,
            showGlobalFilter,
            showToolbarDropZone }, tableOptions.state) }));
    // @ts-ignore
    table.refs = {
        // @ts-ignore
        bottomToolbarRef,
        editInputRefs,
        filterInputRefs,
        // @ts-ignore
        searchInputRef,
        // @ts-ignore
        tableContainerRef,
        // @ts-ignore
        tableFooterRef,
        tableHeadCellRefs,
        // @ts-ignore
        tableHeadRef,
        // @ts-ignore
        tablePaperRef,
        // @ts-ignore
        topToolbarRef,
    };
    const setCreatingRow = (row) => {
        var _a, _b;
        let _row = row;
        if (row === true) {
            _row = createRow(table);
        }
        (_b = (_a = tableOptions === null || tableOptions === void 0 ? void 0 : tableOptions.onCreatingRowChange) === null || _a === void 0 ? void 0 : _a.call(tableOptions, _row)) !== null && _b !== void 0 ? _b : _setCreatingRow(_row);
    };
    table.setCreatingRow = setCreatingRow;
    table.setColumnFilterFns =
        (_x = tableOptions.onColumnFilterFnsChange) !== null && _x !== void 0 ? _x : setColumnFilterFns;
    table.setDensity = (_y = tableOptions.onDensityChange) !== null && _y !== void 0 ? _y : setDensity;
    table.setDraggingColumn =
        (_z = tableOptions.onDraggingColumnChange) !== null && _z !== void 0 ? _z : setDraggingColumn;
    table.setDraggingRow = (_0 = tableOptions.onDraggingRowChange) !== null && _0 !== void 0 ? _0 : setDraggingRow;
    table.setEditingCell = (_1 = tableOptions.onEditingCellChange) !== null && _1 !== void 0 ? _1 : setEditingCell;
    table.setEditingRow = (_2 = tableOptions.onEditingRowChange) !== null && _2 !== void 0 ? _2 : setEditingRow;
    table.setGlobalFilterFn =
        (_3 = tableOptions.onGlobalFilterFnChange) !== null && _3 !== void 0 ? _3 : setGlobalFilterFn;
    table.setHoveredColumn =
        (_4 = tableOptions.onHoveredColumnChange) !== null && _4 !== void 0 ? _4 : setHoveredColumn;
    table.setHoveredRow = (_5 = tableOptions.onHoveredRowChange) !== null && _5 !== void 0 ? _5 : setHoveredRow;
    table.setIsFullScreen = (_6 = tableOptions.onIsFullScreenChange) !== null && _6 !== void 0 ? _6 : setIsFullScreen;
    table.setShowAlertBanner =
        (_7 = tableOptions.onShowAlertBannerChange) !== null && _7 !== void 0 ? _7 : setShowAlertBanner;
    table.setShowColumnFilters =
        (_8 = tableOptions.onShowColumnFiltersChange) !== null && _8 !== void 0 ? _8 : setShowColumnFilters;
    table.setShowGlobalFilter =
        (_9 = tableOptions.onShowGlobalFilterChange) !== null && _9 !== void 0 ? _9 : setShowGlobalFilter;
    table.setShowToolbarDropZone =
        (_10 = tableOptions.onShowToolbarDropZoneChange) !== null && _10 !== void 0 ? _10 : setShowToolbarDropZone;
    useMRT_Effects(table);
    return table;
};

const useMantineReactTable = (tableOptions) => {
    const parsedTableOptions = useMRT_TableOptions(tableOptions);
    const tableInstance = useMRT_TableInstance(parsedTableOptions);
    return tableInstance;
};

var classes$t = {"symbol":"MRT_FilterOptionMenu-module_symbol__5jq-w"};

const mrtFilterOptions = (localization) => [
    {
        option: 'fuzzy',
        symbol: '',
        label: localization.filterFuzzy,
        divider: false,
    },
    {
        option: 'contains',
        symbol: '*',
        label: localization.filterContains,
        divider: false,
    },
    {
        option: 'startsWith',
        symbol: 'a',
        label: localization.filterStartsWith,
        divider: false,
    },
    {
        option: 'endsWith',
        symbol: 'z',
        label: localization.filterEndsWith,
        divider: true,
    },
    {
        option: 'equals',
        symbol: '=',
        label: localization.filterEquals,
        divider: false,
    },
    {
        option: 'notEquals',
        symbol: '',
        label: localization.filterNotEquals,
        divider: true,
    },
    {
        option: 'between',
        symbol: '',
        label: localization.filterBetween,
        divider: false,
    },
    {
        option: 'betweenInclusive',
        symbol: '',
        label: localization.filterBetweenInclusive,
        divider: true,
    },
    {
        option: 'greaterThan',
        symbol: '>',
        label: localization.filterGreaterThan,
        divider: false,
    },
    {
        option: 'greaterThanOrEqualTo',
        symbol: '',
        label: localization.filterGreaterThanOrEqualTo,
        divider: false,
    },
    {
        option: 'lessThan',
        symbol: '<',
        label: localization.filterLessThan,
        divider: false,
    },
    {
        option: 'lessThanOrEqualTo',
        symbol: '',
        label: localization.filterLessThanOrEqualTo,
        divider: true,
    },
    {
        option: 'empty',
        symbol: '',
        label: localization.filterEmpty,
        divider: false,
    },
    {
        option: 'notEmpty',
        symbol: '!',
        label: localization.filterNotEmpty,
        divider: false,
    },
];
const rangeModes = ['between', 'betweenInclusive', 'inNumberRange'];
const emptyModes = ['empty', 'notEmpty'];
const arrModes = ['arrIncludesSome', 'arrIncludesAll', 'arrIncludes'];
const rangeVariants = ['range-slider', 'date-range', 'range'];
const MRT_FilterOptionMenu = ({ header, onSelect, table, }) => {
    var _a, _b, _c, _d;
    const { getState, options: { columnFilterModeOptions, globalFilterModeOptions, localization, renderColumnFilterModeMenuItems, renderGlobalFilterModeMenuItems, }, setColumnFilterFns, setGlobalFilterFn, } = table;
    const { globalFilterFn } = getState();
    const { column } = header !== null && header !== void 0 ? header : {};
    const { columnDef } = column !== null && column !== void 0 ? column : {};
    const currentFilterValue = column === null || column === void 0 ? void 0 : column.getFilterValue();
    let allowedColumnFilterOptions = (_a = columnDef === null || columnDef === void 0 ? void 0 : columnDef.columnFilterModeOptions) !== null && _a !== void 0 ? _a : columnFilterModeOptions;
    if (rangeVariants.includes(columnDef === null || columnDef === void 0 ? void 0 : columnDef.filterVariant)) {
        allowedColumnFilterOptions = [
            ...rangeModes,
            ...(allowedColumnFilterOptions !== null && allowedColumnFilterOptions !== void 0 ? allowedColumnFilterOptions : []),
        ].filter((option) => rangeModes.includes(option));
    }
    const internalFilterOptions = react.useMemo(() => mrtFilterOptions(localization).filter((filterOption) => columnDef
        ? allowedColumnFilterOptions === undefined ||
            (allowedColumnFilterOptions === null || allowedColumnFilterOptions === void 0 ? void 0 : allowedColumnFilterOptions.includes(filterOption.option))
        : (!globalFilterModeOptions ||
            globalFilterModeOptions.includes(filterOption.option)) &&
            ['fuzzy', 'contains', 'startsWith'].includes(filterOption.option)), []);
    const handleSelectFilterMode = (option) => {
        var _a;
        const prevFilterMode = (_a = columnDef === null || columnDef === void 0 ? void 0 : columnDef._filterFn) !== null && _a !== void 0 ? _a : '';
        if (!header || !column) {
            // global filter mode
            setGlobalFilterFn(option);
        }
        else if (option !== prevFilterMode) {
            // column filter mode
            setColumnFilterFns((prev) => (Object.assign(Object.assign({}, prev), { [header.id]: option })));
            // reset filter value and/or perform new filter render
            if (emptyModes.includes(option)) {
                // will now be empty/notEmpty filter mode
                if (currentFilterValue !== ' ' &&
                    !emptyModes.includes(prevFilterMode)) {
                    column.setFilterValue(' ');
                }
                else if (currentFilterValue) {
                    column.setFilterValue(currentFilterValue); // perform new filter render
                }
            }
            else if ((columnDef === null || columnDef === void 0 ? void 0 : columnDef.filterVariant) === 'multi-select' ||
                arrModes.includes(option)) {
                // will now be array filter mode
                if (currentFilterValue instanceof String ||
                    (currentFilterValue === null || currentFilterValue === void 0 ? void 0 : currentFilterValue.length)) {
                    column.setFilterValue([]);
                }
                else if (currentFilterValue) {
                    column.setFilterValue(currentFilterValue); // perform new filter render
                }
            }
            else if (rangeVariants.includes(columnDef === null || columnDef === void 0 ? void 0 : columnDef.filterVariant) ||
                rangeModes.includes(option)) {
                // will now be range filter mode
                if (!Array.isArray(currentFilterValue) ||
                    (!(currentFilterValue === null || currentFilterValue === void 0 ? void 0 : currentFilterValue.every((v) => v === '')) &&
                        !rangeModes.includes(prevFilterMode))) {
                    column.setFilterValue(['', '']);
                }
                else {
                    column.setFilterValue(currentFilterValue); // perform new filter render
                }
            }
            else {
                // will now be single value filter mode
                if (Array.isArray(currentFilterValue)) {
                    column.setFilterValue('');
                }
                else {
                    column.setFilterValue(currentFilterValue); // perform new filter render
                }
            }
        }
        onSelect === null || onSelect === void 0 ? void 0 : onSelect();
    };
    const filterOption = !!header && columnDef ? columnDef._filterFn : globalFilterFn;
    return (jsxRuntime.jsx(core.Menu.Dropdown, { children: (_d = (header && column && columnDef
            ? (_c = (_b = columnDef.renderColumnFilterModeMenuItems) === null || _b === void 0 ? void 0 : _b.call(columnDef, {
                column: column,
                internalFilterOptions,
                onSelectFilterMode: handleSelectFilterMode,
                table,
            })) !== null && _c !== void 0 ? _c : renderColumnFilterModeMenuItems === null || renderColumnFilterModeMenuItems === void 0 ? void 0 : renderColumnFilterModeMenuItems({
                column: column,
                internalFilterOptions,
                onSelectFilterMode: handleSelectFilterMode,
                table,
            })
            : renderGlobalFilterModeMenuItems === null || renderGlobalFilterModeMenuItems === void 0 ? void 0 : renderGlobalFilterModeMenuItems({
                internalFilterOptions,
                onSelectFilterMode: handleSelectFilterMode,
                table,
            }))) !== null && _d !== void 0 ? _d : internalFilterOptions.map(({ option, label, divider, symbol }, index) => (jsxRuntime.jsxs(react.Fragment, { children: [jsxRuntime.jsx(core.Menu.Item, { onClick: () => handleSelectFilterMode(option), color: option === filterOption ? 'blue' : undefined, value: option, leftSection: jsxRuntime.jsx("span", { className: classes$t.symbol, children: symbol }), children: label }), divider && jsxRuntime.jsx(core.Menu.Divider, {})] }, index))) }));
};

var classes$s = {"root":"MRT_GlobalFilterTextInput-module_root__68P5l","collapse":"MRT_GlobalFilterTextInput-module_collapse__1IEZF"};

const MRT_GlobalFilterTextInput = (_a) => {
    var { table } = _a, rest = __rest(_a, ["table"]);
    const { getState, setGlobalFilter, options: { enableGlobalFilterModes, icons: { IconSearch, IconX }, localization, manualFiltering, mantineSearchTextInputProps, }, refs: { searchInputRef }, } = table;
    const { globalFilter, showGlobalFilter } = getState();
    const textFieldProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(mantineSearchTextInputProps, {
        table,
    })), rest);
    const isMounted = react.useRef(false);
    const [searchValue, setSearchValue] = react.useState(globalFilter !== null && globalFilter !== void 0 ? globalFilter : '');
    const [debouncedSearchValue] = hooks.useDebouncedValue(searchValue, manualFiltering ? 500 : 250);
    react.useEffect(() => {
        setGlobalFilter(debouncedSearchValue || undefined);
    }, [debouncedSearchValue]);
    const handleClear = () => {
        setSearchValue('');
        setGlobalFilter(undefined);
    };
    react.useEffect(() => {
        if (isMounted.current) {
            if (globalFilter === undefined) {
                handleClear();
            }
            else {
                setSearchValue(globalFilter);
            }
        }
        isMounted.current = true;
    }, [globalFilter]);
    return (jsxRuntime.jsxs(core.Collapse, { in: showGlobalFilter, className: classes$s.collapse, children: [enableGlobalFilterModes && (jsxRuntime.jsxs(core.Menu, { withinPortal: true, children: [jsxRuntime.jsx(core.Menu.Target, { children: jsxRuntime.jsx(core.ActionIcon, { "aria-label": localization.changeSearchMode, color: "gray", size: "sm", variant: "transparent", children: jsxRuntime.jsx(IconSearch, {}) }) }), jsxRuntime.jsx(MRT_FilterOptionMenu, { table: table, onSelect: handleClear })] })), jsxRuntime.jsx(core.TextInput, Object.assign({ placeholder: localization.search, onChange: (event) => setSearchValue(event.target.value), value: searchValue !== null && searchValue !== void 0 ? searchValue : '', variant: "filled", mt: 0, leftSection: !enableGlobalFilterModes && jsxRuntime.jsx(IconSearch, {}), rightSection: searchValue ? (jsxRuntime.jsx(core.ActionIcon, { "aria-label": localization.clearSearch, color: "gray", disabled: !(searchValue === null || searchValue === void 0 ? void 0 : searchValue.length), onClick: handleClear, size: "sm", variant: "transparent", children: jsxRuntime.jsx(core.Tooltip, { withinPortal: true, label: localization.clearSearch, children: jsxRuntime.jsx(IconX, {}) }) })) : null }, textFieldProps, { ref: (node) => {
                    if (node) {
                        searchInputRef.current = node;
                        if (textFieldProps === null || textFieldProps === void 0 ? void 0 : textFieldProps.ref) {
                            // @ts-ignore
                            textFieldProps.ref = node;
                        }
                    }
                }, className: clsx('mrt-global-filter-text-input', classes$s.root, textFieldProps === null || textFieldProps === void 0 ? void 0 : textFieldProps.className) }))] }));
};

var classes$r = {"collapse":"MRT_ProgressBar-module_collapse__5jb9N","collapse-top":"MRT_ProgressBar-module_collapse-top__RGkm-"};

const MRT_ProgressBar = ({ isTopToolbar, table, }) => {
    const { options: { mantineProgressProps }, getState, } = table;
    const { isSaving, showProgressBars } = getState();
    const linearProgressProps = parseFromValuesOrFunc(mantineProgressProps, {
        isTopToolbar,
        table,
    });
    return (jsxRuntime.jsx(core.Collapse, { in: isSaving || showProgressBars, className: clsx(classes$r.collapse, isTopToolbar && classes$r['collapse-top']), children: jsxRuntime.jsx(core.Progress, Object.assign({ animated: true, "aria-busy": "true", "aria-label": "Loading", radius: 0, value: 100 }, linearProgressProps)) }));
};

var classes$q = {"root":"MRT_TablePagination-module_root__htEye","pagesize":"MRT_TablePagination-module_pagesize__CbS02","with-top-margin":"MRT_TablePagination-module_with-top-margin__dVoCP"};

const defaultRowsPerPage = [5, 10, 15, 20, 25, 30, 50, 100].map((x) => x.toString());
const MRT_TablePagination = ({ table, position = 'bottom', }) => {
    var _a;
    const { getPrePaginationRowModel, getState, setPageIndex, setPageSize, options: { enableToolbarInternalActions, icons: { IconChevronLeftPipe, IconChevronRightPipe, IconChevronLeft, IconChevronRight, }, localization, mantinePaginationProps, paginationDisplayMode, rowCount, }, } = table;
    const { pagination: { pageSize = 10, pageIndex = 0 }, showGlobalFilter, } = getState();
    const paginationProps = parseFromValuesOrFunc(mantinePaginationProps, {
        table,
    });
    const totalRowCount = rowCount !== null && rowCount !== void 0 ? rowCount : getPrePaginationRowModel().rows.length;
    const numberOfPages = Math.ceil(totalRowCount / pageSize);
    const showFirstLastPageButtons = numberOfPages > 2;
    const firstRowIndex = pageIndex * pageSize;
    const lastRowIndex = Math.min(pageIndex * pageSize + pageSize, totalRowCount);
    const _b = paginationProps !== null && paginationProps !== void 0 ? paginationProps : {}, { rowsPerPageOptions = defaultRowsPerPage, showRowsPerPage = true, withEdges = showFirstLastPageButtons } = _b, rest = __rest(_b, ["rowsPerPageOptions", "showRowsPerPage", "withEdges"]);
    const needsTopMargin = position === 'top' && enableToolbarInternalActions && !showGlobalFilter;
    return (jsxRuntime.jsxs(core.Box, { className: clsx('mrt-table-pagination', classes$q.root, needsTopMargin && classes$q['with-top-margin']), children: [(paginationProps === null || paginationProps === void 0 ? void 0 : paginationProps.showRowsPerPage) !== false && (jsxRuntime.jsxs(core.Group, { gap: "xs", children: [jsxRuntime.jsx(core.Text, { id: "rpp-label", children: localization.rowsPerPage }), jsxRuntime.jsx(core.Select, { "aria-labelledby": "rpp-label", className: classes$q.pagesize, data: (_a = paginationProps === null || paginationProps === void 0 ? void 0 : paginationProps.rowsPerPageOptions) !== null && _a !== void 0 ? _a : defaultRowsPerPage, onChange: (value) => setPageSize(+value), value: pageSize.toString(), allowDeselect: false })] })), paginationDisplayMode === 'pages' ? (jsxRuntime.jsx(core.Pagination, Object.assign({ onChange: (newPageIndex) => setPageIndex(newPageIndex - 1), total: numberOfPages, value: pageIndex + 1, withEdges: withEdges, nextIcon: IconChevronRight, previousIcon: IconChevronLeft, firstIcon: IconChevronLeftPipe, lastIcon: IconChevronRightPipe }, rest))) : paginationDisplayMode === 'default' ? (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx(core.Text, { children: `${lastRowIndex === 0 ? 0 : (firstRowIndex + 1).toLocaleString()}-${lastRowIndex.toLocaleString()} ${localization.of} ${totalRowCount.toLocaleString()}` }), jsxRuntime.jsxs(core.Group, { gap: 6, children: [withEdges && (jsxRuntime.jsx(core.ActionIcon, { "aria-label": localization.goToFirstPage, disabled: pageIndex <= 0, onClick: () => setPageIndex(0), variant: "subtle", color: "gray", children: jsxRuntime.jsx(IconChevronLeftPipe, {}) })), jsxRuntime.jsx(core.ActionIcon, { "aria-label": localization.goToPreviousPage, disabled: pageIndex <= 0, onClick: () => setPageIndex(pageIndex - 1), variant: "subtle", color: "gray", children: jsxRuntime.jsx(IconChevronLeft, {}) }), jsxRuntime.jsx(core.ActionIcon, { "aria-label": localization.goToNextPage, disabled: lastRowIndex >= totalRowCount, onClick: () => setPageIndex(pageIndex + 1), variant: "subtle", color: "gray", children: jsxRuntime.jsx(IconChevronRight, {}) }), withEdges && (jsxRuntime.jsx(core.ActionIcon, { "aria-label": localization.goToLastPage, disabled: lastRowIndex >= totalRowCount, onClick: () => setPageIndex(numberOfPages - 1), variant: "subtle", color: "gray", children: jsxRuntime.jsx(IconChevronRightPipe, {}) }))] })] })) : null] }));
};

var classes$p = {"root":"MRT_FilterCheckBox-module_root__Hork4"};

const MRT_FilterCheckbox = ({ column, table, }) => {
    var _a, _b, _c;
    const { getState, options: { localization, mantineFilterCheckboxProps }, } = table;
    const { density } = getState();
    const { columnDef } = column;
    const arg = { column, table };
    const checkboxProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(mantineFilterCheckboxProps, arg)), parseFromValuesOrFunc(columnDef.mantineFilterCheckboxProps, arg));
    const filterLabel = (_a = localization.filterByColumn) === null || _a === void 0 ? void 0 : _a.replace('{column}', columnDef.header);
    const value = column.getFilterValue();
    return (jsxRuntime.jsx(core.Tooltip, { withinPortal: true, openDelay: 1000, label: (_b = checkboxProps === null || checkboxProps === void 0 ? void 0 : checkboxProps.title) !== null && _b !== void 0 ? _b : filterLabel, children: jsxRuntime.jsx(core.Checkbox, Object.assign({ className: clsx('mrt-filter-checkbox', classes$p.root), checked: value === 'true', indeterminate: value === undefined, size: density === 'xs' ? 'sm' : 'md', label: (_c = checkboxProps.title) !== null && _c !== void 0 ? _c : filterLabel }, checkboxProps, { onClick: (e) => {
                var _a;
                e.stopPropagation();
                (_a = checkboxProps === null || checkboxProps === void 0 ? void 0 : checkboxProps.onClick) === null || _a === void 0 ? void 0 : _a.call(checkboxProps, e);
            }, onChange: (e) => {
                var _a;
                column.setFilterValue(column.getFilterValue() === undefined
                    ? 'true'
                    : column.getFilterValue() === 'true'
                        ? 'false'
                        : undefined);
                (_a = checkboxProps === null || checkboxProps === void 0 ? void 0 : checkboxProps.onChange) === null || _a === void 0 ? void 0 : _a.call(checkboxProps, e);
            }, title: undefined })) }));
};

var classes$o = {"root":"MRT_FilterTextInput-module_root__LBwHw","date-filter":"MRT_FilterTextInput-module_date-filter__H9ANA","range-filter":"MRT_FilterTextInput-module_range-filter__1yWxH","not-filter-chip":"MRT_FilterTextInput-module_not-filter-chip__f90Ga","filter-chip-badge":"MRT_FilterTextInput-module_filter-chip-badge__7pJVz"};

const MRT_FilterTextInput = ({ header, rangeFilterIndex, table, }) => {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const { options: { columnFilterDisplayMode, columnFilterModeOptions, icons: { IconX }, localization, mantineFilterAutocompleteProps, mantineFilterDateInputProps, mantineFilterMultiSelectProps, mantineFilterSelectProps, mantineFilterTextInputProps, manualFiltering, }, refs: { filterInputRefs }, setColumnFilterFns, } = table;
    const { column } = header;
    const { columnDef } = column;
    const arg = { column, table, rangeFilterIndex };
    const textInputProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(mantineFilterTextInputProps, arg)), parseFromValuesOrFunc(columnDef.mantineFilterTextInputProps, arg));
    const selectProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(mantineFilterSelectProps, arg)), parseFromValuesOrFunc(columnDef.mantineFilterSelectProps, arg));
    const multiSelectProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(mantineFilterMultiSelectProps, arg)), parseFromValuesOrFunc(columnDef.mantineFilterMultiSelectProps, arg));
    const dateInputProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(mantineFilterDateInputProps, arg)), parseFromValuesOrFunc(columnDef.mantineFilterDateInputProps, arg));
    const autoCompleteProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(mantineFilterAutocompleteProps, arg)), parseFromValuesOrFunc(columnDef.mantineFilterAutocompleteProps, arg));
    const isRangeFilter = columnDef.filterVariant === 'range' ||
        columnDef.filterVariant === 'date-range' ||
        rangeFilterIndex !== undefined;
    const isSelectFilter = columnDef.filterVariant === 'select';
    const isMultiSelectFilter = columnDef.filterVariant === 'multi-select';
    const isDateFilter = columnDef.filterVariant === 'date' ||
        columnDef.filterVariant === 'date-range';
    const isAutoCompleteFilter = columnDef.filterVariant === 'autocomplete';
    const allowedColumnFilterOptions = (_a = columnDef === null || columnDef === void 0 ? void 0 : columnDef.columnFilterModeOptions) !== null && _a !== void 0 ? _a : columnFilterModeOptions;
    const currentFilterOption = columnDef._filterFn;
    const filterChipLabel = ['empty', 'notEmpty'].includes(currentFilterOption)
        ? localizedFilterOption(localization, currentFilterOption)
        : '';
    const filterPlaceholder = !isRangeFilter
        ? (_b = textInputProps === null || textInputProps === void 0 ? void 0 : textInputProps.placeholder) !== null && _b !== void 0 ? _b : (_c = localization.filterByColumn) === null || _c === void 0 ? void 0 : _c.replace('{column}', String(columnDef.header))
        : rangeFilterIndex === 0
            ? localization.min
            : rangeFilterIndex === 1
                ? localization.max
                : '';
    const facetedUniqueValues = column.getFacetedUniqueValues();
    const filterSelectOptions = react.useMemo(() => {
        var _a, _b, _c;
        return ((_c = (_b = (_a = autoCompleteProps === null || autoCompleteProps === void 0 ? void 0 : autoCompleteProps.data) !== null && _a !== void 0 ? _a : selectProps === null || selectProps === void 0 ? void 0 : selectProps.data) !== null && _b !== void 0 ? _b : multiSelectProps === null || multiSelectProps === void 0 ? void 0 : multiSelectProps.data) !== null && _c !== void 0 ? _c : ((isAutoCompleteFilter || isSelectFilter || isMultiSelectFilter) &&
            facetedUniqueValues
            ? Array.from(facetedUniqueValues.keys()).sort((a, b) => a.localeCompare(b))
            : []))
            //@ts-ignore
            .filter((o) => o !== undefined && o !== null);
    }, [
        autoCompleteProps === null || autoCompleteProps === void 0 ? void 0 : autoCompleteProps.data,
        facetedUniqueValues,
        isAutoCompleteFilter,
        isMultiSelectFilter,
        isSelectFilter,
        multiSelectProps === null || multiSelectProps === void 0 ? void 0 : multiSelectProps.data,
        selectProps === null || selectProps === void 0 ? void 0 : selectProps.data,
    ]);
    const isMounted = react.useRef(false);
    const [filterValue, setFilterValue] = react.useState(() => {
        var _a, _b;
        return isMultiSelectFilter
            ? column.getFilterValue() || []
            : isRangeFilter
                ? ((_a = column.getFilterValue()) === null || _a === void 0 ? void 0 : _a[rangeFilterIndex]) || ''
                : (_b = column.getFilterValue()) !== null && _b !== void 0 ? _b : '';
    });
    const [debouncedFilterValue] = hooks.useDebouncedValue(filterValue, manualFiltering ? 400 : 200);
    //send debounced filterValue to table instance
    react.useEffect(() => {
        if (!isMounted.current)
            return;
        if (isRangeFilter) {
            column.setFilterValue((old) => {
                const newFilterValues = Array.isArray(old) ? old : ['', ''];
                newFilterValues[rangeFilterIndex] =
                    debouncedFilterValue;
                return newFilterValues;
            });
        }
        else {
            column.setFilterValue(debouncedFilterValue !== null && debouncedFilterValue !== void 0 ? debouncedFilterValue : undefined);
        }
    }, [debouncedFilterValue]);
    //receive table filter value and set it to local state
    react.useEffect(() => {
        if (!isMounted.current) {
            isMounted.current = true;
            return;
        }
        const tableFilterValue = column.getFilterValue();
        if (tableFilterValue === undefined) {
            handleClear();
        }
        else if (isRangeFilter && rangeFilterIndex !== undefined) {
            setFilterValue((tableFilterValue !== null && tableFilterValue !== void 0 ? tableFilterValue : ['', ''])[rangeFilterIndex]);
        }
        else {
            setFilterValue(tableFilterValue !== null && tableFilterValue !== void 0 ? tableFilterValue : '');
        }
    }, [column.getFilterValue()]);
    const handleClear = () => {
        if (isMultiSelectFilter) {
            setFilterValue([]);
            column.setFilterValue([]);
        }
        else if (isRangeFilter) {
            setFilterValue('');
            column.setFilterValue((old) => {
                const newFilterValues = Array.isArray(old) ? old : ['', ''];
                newFilterValues[rangeFilterIndex] = undefined;
                return newFilterValues;
            });
        }
        else {
            setFilterValue('');
            column.setFilterValue(undefined);
        }
    };
    if (columnDef.Filter) {
        return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: (_d = columnDef.Filter) === null || _d === void 0 ? void 0 : _d.call(columnDef, { column, header, rangeFilterIndex, table }) }));
    }
    const handleClearEmptyFilterChip = () => {
        setFilterValue('');
        column.setFilterValue(undefined);
        setColumnFilterFns((prev) => {
            var _a;
            return (Object.assign(Object.assign({}, prev), { [header.id]: (_a = allowedColumnFilterOptions === null || allowedColumnFilterOptions === void 0 ? void 0 : allowedColumnFilterOptions[0]) !== null && _a !== void 0 ? _a : 'fuzzy' }));
        });
    };
    const _j = {
        disabled: !!filterChipLabel,
        placeholder: filterPlaceholder,
        title: filterPlaceholder,
        'aria-label': filterPlaceholder,
        onClick: (event) => event.stopPropagation(),
        onChange: setFilterValue,
        value: filterValue,
        variant: 'unstyled',
        className: clsx('mrt-filter-text-input', classes$o.root, isDateFilter
            ? classes$o['date-filter']
            : isRangeFilter
                ? classes$o['range-filter']
                : !filterChipLabel && classes$o['not-filter-chip']),
        style: Object.assign({}, (isMultiSelectFilter
            ? multiSelectProps === null || multiSelectProps === void 0 ? void 0 : multiSelectProps.style
            : isSelectFilter
                ? selectProps === null || selectProps === void 0 ? void 0 : selectProps.style
                : isDateFilter
                    ? dateInputProps === null || dateInputProps === void 0 ? void 0 : dateInputProps.style
                    : textInputProps === null || textInputProps === void 0 ? void 0 : textInputProps.style)),
    }, { className } = _j, commonProps = __rest(_j, ["className"]);
    const ClearButton = filterValue ? (jsxRuntime.jsx(core.ActionIcon, { "aria-label": localization.clearFilter, color: "var(--mantine-color-gray-7)", onClick: handleClear, size: "sm", title: (_e = localization.clearFilter) !== null && _e !== void 0 ? _e : '', variant: "transparent", children: jsxRuntime.jsx(IconX, {}) })) : null;
    return filterChipLabel ? (jsxRuntime.jsx(core.Box, { style: commonProps.style, children: jsxRuntime.jsx(core.Badge, { size: "lg", onClick: handleClearEmptyFilterChip, className: classes$o['filter-chip-badge'], rightSection: ClearButton, children: filterChipLabel }) })) : isMultiSelectFilter ? (jsxRuntime.jsx(core.MultiSelect, Object.assign({}, commonProps, { searchable: true }, multiSelectProps, { onChange: (value) => setFilterValue(value), className: clsx(className, multiSelectProps.className), data: filterSelectOptions, ref: (node) => {
            if (node) {
                filterInputRefs.current[`${column.id}-${rangeFilterIndex !== null && rangeFilterIndex !== void 0 ? rangeFilterIndex : 0}`] =
                    node;
                if (multiSelectProps.ref) {
                    multiSelectProps.ref.current = node;
                }
            }
        }, style: commonProps.style, rightSection: ((_f = filterValue === null || filterValue === void 0 ? void 0 : filterValue.toString()) === null || _f === void 0 ? void 0 : _f.length) ? ClearButton : undefined }))) : isSelectFilter ? (jsxRuntime.jsx(core.Select, Object.assign({}, commonProps, { searchable: true, clearable: true }, selectProps, { className: clsx(className, selectProps.className), data: filterSelectOptions, style: commonProps.style, ref: (node) => {
            if (node) {
                filterInputRefs.current[`${column.id}-${rangeFilterIndex !== null && rangeFilterIndex !== void 0 ? rangeFilterIndex : 0}`] =
                    node;
                if (selectProps.ref) {
                    selectProps.ref.current = node;
                }
            }
        }, clearButtonProps: {
            size: 'md',
        } }))) : isDateFilter ? (jsxRuntime.jsx(dates.DateInput, Object.assign({}, commonProps, { allowDeselect: true, clearable: true, popoverProps: { withinPortal: columnFilterDisplayMode !== 'popover' } }, dateInputProps, { className: clsx(className, dateInputProps.className), ref: (node) => {
            if (node) {
                filterInputRefs.current[`${column.id}-${rangeFilterIndex !== null && rangeFilterIndex !== void 0 ? rangeFilterIndex : 0}`] =
                    node;
                if (dateInputProps.ref) {
                    dateInputProps.ref.current = node;
                }
            }
        }, style: commonProps.style }))) : isAutoCompleteFilter ? (jsxRuntime.jsx(core.Autocomplete, Object.assign({}, commonProps, { rightSection: ((_g = filterValue === null || filterValue === void 0 ? void 0 : filterValue.toString()) === null || _g === void 0 ? void 0 : _g.length) ? ClearButton : undefined, onChange: (value) => setFilterValue(value) }, autoCompleteProps, { className: clsx(className, autoCompleteProps.className), data: filterSelectOptions, ref: (node) => {
            if (node) {
                filterInputRefs.current[`${column.id}-${rangeFilterIndex !== null && rangeFilterIndex !== void 0 ? rangeFilterIndex : 0}`] =
                    node;
                if (autoCompleteProps.ref) {
                    autoCompleteProps.ref.current = node;
                }
            }
        }, style: commonProps.style }))) : (jsxRuntime.jsx(core.TextInput, Object.assign({}, commonProps, { rightSection: ((_h = filterValue === null || filterValue === void 0 ? void 0 : filterValue.toString()) === null || _h === void 0 ? void 0 : _h.length) ? ClearButton : undefined, onChange: (e) => setFilterValue(e.target.value) }, textInputProps, { className: clsx(className, textInputProps.className), mt: 0, ref: (node) => {
            if (node) {
                filterInputRefs.current[`${column.id}-${rangeFilterIndex !== null && rangeFilterIndex !== void 0 ? rangeFilterIndex : 0}`] =
                    node;
                if (textInputProps.ref) {
                    textInputProps.ref.current = node;
                }
            }
        }, style: commonProps.style })));
};

var classes$n = {"root":"MRT_FilterRangeFields-module_root__Ci-Oq"};

const MRT_FilterRangeFields = ({ header, table, }) => {
    return (jsxRuntime.jsxs(core.Box, { className: clsx('mrt-filter-range-fields', classes$n.root), children: [jsxRuntime.jsx(MRT_FilterTextInput, { header: header, rangeFilterIndex: 0, table: table }), jsxRuntime.jsx(MRT_FilterTextInput, { header: header, rangeFilterIndex: 1, table: table })] }));
};

var classes$m = {"alert":"MRT_ToolbarAlertBanner-module_alert__7thQ7","alert-stacked":"MRT_ToolbarAlertBanner-module_alert-stacked__L6H0N","alert-bottom":"MRT_ToolbarAlertBanner-module_alert-bottom__dNYrb","alert-badge":"MRT_ToolbarAlertBanner-module_alert-badge__WM5Xi","toolbar-alert":"MRT_ToolbarAlertBanner-module_toolbar-alert__0V-BV","head-overlay":"MRT_ToolbarAlertBanner-module_head-overlay__t42J-"};

const MRT_ToolbarAlertBanner = ({ stackAlertBanner, table, }) => {
    var _a, _b, _c;
    const { getPrePaginationRowModel, getSelectedRowModel, getState, options: { enableRowSelection, enableSelectAll, icons: { IconX }, localization, mantineToolbarAlertBannerBadgeProps, mantineToolbarAlertBannerProps, positionToolbarAlertBanner, renderToolbarAlertBannerContent, rowCount, }, } = table;
    const { grouping, showAlertBanner, density } = getState();
    const alertProps = parseFromValuesOrFunc(mantineToolbarAlertBannerProps, {
        table,
    });
    const badgeProps = parseFromValuesOrFunc(mantineToolbarAlertBannerBadgeProps, { table });
    const selectedAlert = getSelectedRowModel().rows.length > 0
        ? (_b = (_a = localization.selectedCountOfRowCountRowsSelected) === null || _a === void 0 ? void 0 : _a.replace('{selectedCount}', getSelectedRowModel().rows.length.toString())) === null || _b === void 0 ? void 0 : _b.replace('{rowCount}', (rowCount !== null && rowCount !== void 0 ? rowCount : getPrePaginationRowModel().rows.length).toString())
        : null;
    const groupedAlert = grouping.length > 0 ? (jsxRuntime.jsxs(core.Flex, { children: [localization.groupedBy, ' ', grouping.map((columnId, index) => (jsxRuntime.jsxs(react.Fragment, { children: [index > 0 ? localization.thenBy : '', jsxRuntime.jsxs(core.Badge, Object.assign({ rightSection: jsxRuntime.jsx(core.ActionIcon, { onClick: () => table.getColumn(columnId).toggleGrouping(), size: "xs", children: jsxRuntime.jsx(IconX, {}) }), className: classes$m['alert-badge'], variant: "filled" }, badgeProps, { children: [table.getColumn(columnId).columnDef.header, ' '] }))] }, `${index}-${columnId}`)))] })) : null;
    return (jsxRuntime.jsx(core.Collapse, { in: showAlertBanner || !!selectedAlert || !!groupedAlert, transitionDuration: stackAlertBanner ? 200 : 0, children: jsxRuntime.jsx(core.Alert, Object.assign({ color: "blue", icon: false }, alertProps, { className: clsx(classes$m.alert, stackAlertBanner &&
                !positionToolbarAlertBanner &&
                classes$m['alert-stacked'], !stackAlertBanner &&
                positionToolbarAlertBanner === 'bottom' &&
                classes$m['alert-bottom'], alertProps === null || alertProps === void 0 ? void 0 : alertProps.className), children: (_c = renderToolbarAlertBannerContent === null || renderToolbarAlertBannerContent === void 0 ? void 0 : renderToolbarAlertBannerContent({
                groupedAlert,
                selectedAlert,
                table,
            })) !== null && _c !== void 0 ? _c : (jsxRuntime.jsxs(core.Flex, { className: clsx(classes$m['toolbar-alert'], positionToolbarAlertBanner === 'head-overlay' &&
                    classes$m['head-overlay'], density), children: [enableRowSelection &&
                        enableSelectAll &&
                        positionToolbarAlertBanner === 'head-overlay' && (jsxRuntime.jsx(MRT_SelectCheckbox, { selectAll: true, table: table })), jsxRuntime.jsxs(core.Stack, { children: [alertProps === null || alertProps === void 0 ? void 0 : alertProps.children, (alertProps === null || alertProps === void 0 ? void 0 : alertProps.children) && (selectedAlert || groupedAlert) && (jsxRuntime.jsx("br", {})), selectedAlert, selectedAlert && groupedAlert && jsxRuntime.jsx("br", {}), groupedAlert] })] })) })) }));
};

var classes$l = {"root":"MRT_ColumnPinningButtons-module_root__HTo-K","left":"MRT_ColumnPinningButtons-module_left__QPyU1","right":"MRT_ColumnPinningButtons-module_right__FSDcf"};

const MRT_ColumnPinningButtons = ({ column, table: { options: { icons: { IconPinned, IconPinnedOff }, localization, }, }, }) => {
    return (jsxRuntime.jsx(core.Flex, { className: clsx('mrt-column-pinning-buttons', classes$l.root), children: column.getIsPinned() ? (jsxRuntime.jsx(core.Tooltip, { withinPortal: true, label: localization.unpin, children: jsxRuntime.jsx(core.ActionIcon, { onClick: () => column.pin(false), color: "gray", variant: "default", size: "md", children: jsxRuntime.jsx(IconPinnedOff, {}) }) })) : (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx(core.Tooltip, { withinPortal: true, label: localization.pinToLeft, children: jsxRuntime.jsx(core.ActionIcon, { onClick: () => column.pin('left'), color: "gray", variant: "default", size: "md", children: jsxRuntime.jsx(IconPinned, { className: classes$l.left }) }) }), jsxRuntime.jsx(core.Tooltip, { withinPortal: true, label: localization.pinToRight, children: jsxRuntime.jsx(core.ActionIcon, { onClick: () => column.pin('right'), color: "gray", variant: "default", size: "md", children: jsxRuntime.jsx(IconPinned, { className: classes$l.right }) }) })] })) }));
};

function dataVariable(name, value) {
    const key = `data-${name}`;
    switch (typeof value) {
        case 'boolean':
            return value ? { [key]: '' } : null;
        case 'number':
            return { [key]: `${value}` };
        case 'string':
            return { [key]: value };
        default:
            return null;
    }
}

var classes$k = {"root":"MRT_ShowHideColumnsMenuItems-module_root__62obc","menu":"MRT_ShowHideColumnsMenuItems-module_menu__ziqXu","grab":"MRT_ShowHideColumnsMenuItems-module_grab__-CDIp","pin":"MRT_ShowHideColumnsMenuItems-module_pin__linHc","switch":"MRT_ShowHideColumnsMenuItems-module_switch__FyPF3","header":"MRT_ShowHideColumnsMenuItems-module_header__3Y1fj"};

const MRT_ShowHideColumnsMenuItems = ({ allColumns, hoveredColumn, setHoveredColumn, column, table, }) => {
    var _a;
    const theme = core.useMantineTheme();
    const { getState, options: { enableColumnOrdering, enableHiding, enableColumnPinning, localization, }, setColumnOrder, } = table;
    const { columnOrder } = getState();
    const { columnDef } = column;
    const { columnDefType } = columnDef;
    const switchChecked = (columnDefType !== 'group' && column.getIsVisible()) ||
        (columnDefType === 'group' &&
            column.getLeafColumns().some((col) => col.getIsVisible()));
    const handleToggleColumnHidden = (column) => {
        var _a, _b;
        if (columnDefType === 'group') {
            (_b = (_a = column === null || column === void 0 ? void 0 : column.columns) === null || _a === void 0 ? void 0 : _a.forEach) === null || _b === void 0 ? void 0 : _b.call(_a, (childColumn) => {
                childColumn.toggleVisibility(!switchChecked);
            });
        }
        else {
            column.toggleVisibility();
        }
    };
    const menuItemRef = react.useRef(null);
    const [isDragging, setIsDragging] = react.useState(false);
    const handleDragStart = (e) => {
        setIsDragging(true);
        e.dataTransfer.setDragImage(menuItemRef.current, 0, 0);
    };
    const handleDragEnd = (_e) => {
        setIsDragging(false);
        setHoveredColumn(null);
        if (hoveredColumn) {
            setColumnOrder(reorderColumn(column, hoveredColumn, columnOrder));
        }
    };
    const handleDragEnter = (_e) => {
        if (!isDragging && columnDef.enableColumnOrdering !== false) {
            setHoveredColumn(column);
        }
    };
    if (!columnDef.header || columnDef.visibleInShowHideMenu === false) {
        return null;
    }
    return (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx(core.Menu.Item, Object.assign({ component: "span", ref: menuItemRef, style: {
                    '--_column-depth': `${(column.depth + 0.5) * 2}rem`,
                    '--_hover-color': getPrimaryColor(theme),
                }, onDragEnter: handleDragEnter, className: classes$k.root }, dataVariable('dragging', isDragging), dataVariable('order-hovered', (hoveredColumn === null || hoveredColumn === void 0 ? void 0 : hoveredColumn.id) === column.id), { children: jsxRuntime.jsxs(core.Box, { className: classes$k.menu, children: [columnDefType !== 'group' &&
                            enableColumnOrdering &&
                            !allColumns.some((col) => col.columnDef.columnDefType === 'group') &&
                            (columnDef.enableColumnOrdering !== false ? (jsxRuntime.jsx(MRT_GrabHandleButton, { onDragEnd: handleDragEnd, onDragStart: handleDragStart, table: table })) : (jsxRuntime.jsx(core.Box, { className: classes$k.grab }))), enableColumnPinning &&
                            (column.getCanPin() ? (jsxRuntime.jsx(MRT_ColumnPinningButtons, { column: column, table: table })) : (jsxRuntime.jsx(core.Box, { className: classes$k.pin }))), enableHiding ? (jsxRuntime.jsx(core.Tooltip, { withinPortal: true, openDelay: 1000, label: localization.toggleVisibility, children: jsxRuntime.jsx(core.Switch, { checked: switchChecked, disabled: !column.getCanHide(), label: columnDef.header, onChange: () => handleToggleColumnHidden(column), className: classes$k.switch }) })) : (jsxRuntime.jsx(core.Text, { className: classes$k.header, children: columnDef.header }))] }) })), (_a = column.columns) === null || _a === void 0 ? void 0 : _a.map((c, i) => (jsxRuntime.jsx(MRT_ShowHideColumnsMenuItems, { allColumns: allColumns, column: c, hoveredColumn: hoveredColumn, setHoveredColumn: setHoveredColumn, table: table }, `${i}-${c.id}`)))] }));
};

var classes$j = {"root":"MRT_ShowHideColumnsMenu-module_root__Zspd4","content":"MRT_ShowHideColumnsMenu-module_content__1HDkf"};

const MRT_ShowHideColumnsMenu = ({ table, }) => {
    const { getAllColumns, getAllLeafColumns, getCenterLeafColumns, getIsAllColumnsVisible, getIsSomeColumnsPinned, getIsSomeColumnsVisible, getLeftLeafColumns, getRightLeafColumns, getState, options: { enableColumnOrdering, enableHiding, enableColumnPinning, localization, }, } = table;
    const { columnOrder, columnPinning } = getState();
    const handleToggleAllColumns = (value) => {
        getAllLeafColumns()
            .filter((col) => col.columnDef.enableHiding !== false)
            .forEach((col) => col.toggleVisibility(value));
    };
    const allColumns = react.useMemo(() => {
        const columns = getAllColumns();
        if (columnOrder.length > 0 &&
            !columns.some((col) => col.columnDef.columnDefType === 'group')) {
            return [
                ...getLeftLeafColumns(),
                ...Array.from(new Set(columnOrder)).map((colId) => getCenterLeafColumns().find((col) => (col === null || col === void 0 ? void 0 : col.id) === colId)),
                ...getRightLeafColumns(),
            ].filter(Boolean);
        }
        return columns;
    }, [
        columnOrder,
        columnPinning,
        getAllColumns(),
        getCenterLeafColumns(),
        getLeftLeafColumns(),
        getRightLeafColumns(),
    ]);
    const [hoveredColumn, setHoveredColumn] = react.useState(null);
    return (jsxRuntime.jsxs(core.Menu.Dropdown, { className: clsx('mrt-show-hide-columns-menu', classes$j.root), children: [jsxRuntime.jsxs(core.Flex, { className: classes$j.content, children: [enableHiding && (jsxRuntime.jsx(core.Button, { disabled: !getIsSomeColumnsVisible(), onClick: () => handleToggleAllColumns(false), variant: "subtle", children: localization.hideAll })), enableColumnOrdering && (jsxRuntime.jsx(core.Button, { onClick: () => table.setColumnOrder(getDefaultColumnOrderIds(table.options)), variant: "subtle", children: localization.resetOrder })), enableColumnPinning && (jsxRuntime.jsx(core.Button, { disabled: !getIsSomeColumnsPinned(), onClick: () => table.resetColumnPinning(true), variant: "subtle", children: localization.unpinAll })), enableHiding && (jsxRuntime.jsx(core.Button, { disabled: getIsAllColumnsVisible(), onClick: () => handleToggleAllColumns(true), variant: "subtle", children: localization.showAll }))] }), jsxRuntime.jsx(core.Divider, {}), allColumns.map((column, index) => (jsxRuntime.jsx(MRT_ShowHideColumnsMenuItems, { allColumns: allColumns, column: column, hoveredColumn: hoveredColumn, setHoveredColumn: setHoveredColumn, table: table }, `${index}-${column.id}`)))] }));
};

const MRT_ShowHideColumnsButton = (_a) => {
    var { table, title } = _a, rest = __rest(_a, ["table", "title"]);
    const { icons: { IconColumns }, localization: { showHideColumns }, } = table.options;
    return (jsxRuntime.jsxs(core.Menu, { closeOnItemClick: false, withinPortal: true, children: [jsxRuntime.jsx(core.Tooltip, { withinPortal: true, label: title !== null && title !== void 0 ? title : showHideColumns, children: jsxRuntime.jsx(core.Menu.Target, { children: jsxRuntime.jsx(core.ActionIcon, Object.assign({ color: "gray", size: "lg", variant: "subtle", "aria-label": title !== null && title !== void 0 ? title : showHideColumns }, rest, { children: jsxRuntime.jsx(IconColumns, {}) })) }) }), jsxRuntime.jsx(MRT_ShowHideColumnsMenu, { table: table })] }));
};

const next = {
    xs: 'xl',
    md: 'xs',
    xl: 'md',
};
const MRT_ToggleDensePaddingButton = (_a) => {
    var { table: { getState, options: { icons: { IconBaselineDensityLarge, IconBaselineDensityMedium, IconBaselineDensitySmall, }, localization: { toggleDensity }, }, setDensity, }, title } = _a, rest = __rest(_a, ["table", "title"]);
    const { density } = getState();
    return (jsxRuntime.jsx(core.Tooltip, { withinPortal: true, label: title !== null && title !== void 0 ? title : toggleDensity, children: jsxRuntime.jsx(core.ActionIcon, Object.assign({ color: "gray", size: "lg", variant: "subtle", "aria-label": title !== null && title !== void 0 ? title : toggleDensity, onClick: () => setDensity((current) => next[current]) }, rest, { children: density === 'xs' ? (jsxRuntime.jsx(IconBaselineDensitySmall, {})) : density === 'md' ? (jsxRuntime.jsx(IconBaselineDensityMedium, {})) : (jsxRuntime.jsx(IconBaselineDensityLarge, {})) })) }));
};

const MRT_ToggleFiltersButton = (_a) => {
    var { table: { getState, options: { icons: { IconFilter, IconFilterOff }, localization: { showHideFilters }, }, setShowColumnFilters, }, title } = _a, rest = __rest(_a, ["table", "title"]);
    const { showColumnFilters } = getState();
    return (jsxRuntime.jsx(core.Tooltip, { withinPortal: true, label: title !== null && title !== void 0 ? title : showHideFilters, children: jsxRuntime.jsx(core.ActionIcon, Object.assign({ color: "gray", size: "lg", variant: "subtle", "aria-label": title !== null && title !== void 0 ? title : showHideFilters, onClick: () => setShowColumnFilters((current) => !current) }, rest, { children: showColumnFilters ? jsxRuntime.jsx(IconFilterOff, {}) : jsxRuntime.jsx(IconFilter, {}) })) }));
};

const MRT_ToggleFullScreenButton = (_a) => {
    var { table: { getState, options: { icons: { IconMinimize, IconMaximize }, localization: { toggleFullScreen }, }, setIsFullScreen, }, title } = _a, rest = __rest(_a, ["table", "title"]);
    const { isFullScreen } = getState();
    const [tooltipOpened, setTooltipOpened] = react.useState(false);
    const handleToggleFullScreen = () => {
        setTooltipOpened(false);
        setIsFullScreen((current) => !current);
    };
    return (jsxRuntime.jsx(core.Tooltip, { opened: tooltipOpened, withinPortal: true, label: title !== null && title !== void 0 ? title : toggleFullScreen, children: jsxRuntime.jsx(core.ActionIcon, Object.assign({ color: "gray", size: "lg", variant: "subtle", "aria-label": title !== null && title !== void 0 ? title : toggleFullScreen, onClick: handleToggleFullScreen, onMouseEnter: () => setTooltipOpened(true), onMouseLeave: () => setTooltipOpened(false) }, rest, { children: isFullScreen ? jsxRuntime.jsx(IconMinimize, {}) : jsxRuntime.jsx(IconMaximize, {}) })) }));
};

const MRT_ToggleGlobalFilterButton = (_a) => {
    var { table: { getState, options: { icons: { IconSearch, IconSearchOff }, localization: { showHideSearch }, }, refs: { searchInputRef }, setShowGlobalFilter, }, title } = _a, rest = __rest(_a, ["table", "title"]);
    const { globalFilter, showGlobalFilter } = getState();
    const handleToggleSearch = () => {
        setShowGlobalFilter(!showGlobalFilter);
        setTimeout(() => { var _a; return (_a = searchInputRef.current) === null || _a === void 0 ? void 0 : _a.focus(); }, 100);
    };
    return (jsxRuntime.jsx(core.Tooltip, { withinPortal: true, label: title !== null && title !== void 0 ? title : showHideSearch, children: jsxRuntime.jsx(core.ActionIcon, Object.assign({ color: "gray", size: "lg", variant: "subtle", "aria-label": title !== null && title !== void 0 ? title : showHideSearch, disabled: !!globalFilter, onClick: handleToggleSearch }, rest, { children: showGlobalFilter ? jsxRuntime.jsx(IconSearchOff, {}) : jsxRuntime.jsx(IconSearch, {}) })) }));
};

var classes$i = {"root":"MRT_ToolbarInternalButtons-module_root__u7alT"};

const MRT_ToolbarInternalButtons = ({ table, }) => {
    var _a;
    const { options: { columnFilterDisplayMode, enableColumnFilters, enableColumnOrdering, enableDensityToggle, enableFilters, enableFullScreenToggle, enableGlobalFilter, enableHiding, enableColumnPinning, initialState, renderToolbarInternalActions, }, } = table;
    return (jsxRuntime.jsx(core.Flex, { className: clsx('mrt-toolbar-internal-buttons', classes$i.root), children: (_a = renderToolbarInternalActions === null || renderToolbarInternalActions === void 0 ? void 0 : renderToolbarInternalActions({ table })) !== null && _a !== void 0 ? _a : (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [enableFilters &&
                    enableGlobalFilter &&
                    !(initialState === null || initialState === void 0 ? void 0 : initialState.showGlobalFilter) && (jsxRuntime.jsx(MRT_ToggleGlobalFilterButton, { table: table })), enableFilters &&
                    enableColumnFilters &&
                    columnFilterDisplayMode !== 'popover' && (jsxRuntime.jsx(MRT_ToggleFiltersButton, { table: table })), (enableHiding || enableColumnOrdering || enableColumnPinning) && (jsxRuntime.jsx(MRT_ShowHideColumnsButton, { table: table })), enableDensityToggle && (jsxRuntime.jsx(MRT_ToggleDensePaddingButton, { table: table })), enableFullScreenToggle && (jsxRuntime.jsx(MRT_ToggleFullScreenButton, { table: table }))] })) }));
};

var classes$h = {"root":"MRT_ToolbarDropZone-module_root__UxThK","hovered":"MRT_ToolbarDropZone-module_hovered__Vcqor"};

const MRT_ToolbarDropZone = ({ table, }) => {
    const { getState, options: { enableGrouping, localization }, setHoveredColumn, setShowToolbarDropZone, } = table;
    const { draggingColumn, hoveredColumn, grouping, showToolbarDropZone } = getState();
    const handleDragEnter = (_event) => {
        setHoveredColumn({ id: 'drop-zone' });
    };
    react.useEffect(() => {
        var _a;
        if (((_a = table.options.state) === null || _a === void 0 ? void 0 : _a.showToolbarDropZone) !== undefined) {
            setShowToolbarDropZone(!!enableGrouping &&
                !!draggingColumn &&
                draggingColumn.columnDef.enableGrouping !== false &&
                !grouping.includes(draggingColumn.id));
        }
    }, [enableGrouping, draggingColumn, grouping]);
    return (jsxRuntime.jsx(core.Transition, { mounted: showToolbarDropZone, transition: "fade", children: () => {
            var _a, _b;
            return (jsxRuntime.jsx(core.Flex, { className: clsx('mrt-toolbar-dropzone', classes$h.root, (hoveredColumn === null || hoveredColumn === void 0 ? void 0 : hoveredColumn.id) === 'drop-zone' && classes$h.hovered), onDragEnter: handleDragEnter, children: jsxRuntime.jsx(core.Text, { children: localization.dropToGroupBy.replace('{column}', (_b = (_a = draggingColumn === null || draggingColumn === void 0 ? void 0 : draggingColumn.columnDef) === null || _a === void 0 ? void 0 : _a.header) !== null && _b !== void 0 ? _b : '') }) }));
        } }));
};

var classes$g = {"top-toolbar":"MRT_TopToolbar-module_top-toolbar__3-EkJ","top-toolbar-fullscreen":"MRT_TopToolbar-module_top-toolbar-fullscreen__F7fI2","actions-container":"MRT_TopToolbar-module_actions-container__OROxn","actions-container-stack-alert":"MRT_TopToolbar-module_actions-container-stack-alert__bBWFO"};

var commonClasses = {"common-toolbar-styles":"common-styles-module_common-toolbar-styles__didgq"};

const MRT_TopToolbar = ({ table, }) => {
    var _a;
    const { getState, options: { enableGlobalFilter, enablePagination, enableToolbarInternalActions, mantineTopToolbarProps, positionGlobalFilter, positionPagination, positionToolbarAlertBanner, positionToolbarDropZone, renderTopToolbarCustomActions, }, refs: { topToolbarRef }, } = table;
    const { isFullScreen, showGlobalFilter } = getState();
    const isMobile = hooks.useMediaQuery('(max-width:720px)');
    const isTablet = hooks.useMediaQuery('(max-width:1024px)');
    const toolbarProps = parseFromValuesOrFunc(mantineTopToolbarProps, { table });
    const stackAlertBanner = isMobile ||
        !!renderTopToolbarCustomActions ||
        (showGlobalFilter && isTablet);
    const globalFilterProps = {
        style: !isTablet
            ? {
                zIndex: 3,
            }
            : undefined,
        table,
    };
    return (jsxRuntime.jsxs(core.Box, Object.assign({}, toolbarProps, { className: clsx(commonClasses['common-toolbar-styles'], classes$g['top-toolbar'], isFullScreen && classes$g['top-toolbar-fullscreen'], toolbarProps === null || toolbarProps === void 0 ? void 0 : toolbarProps.className), ref: (node) => {
            if (node) {
                topToolbarRef.current = node;
                if (toolbarProps === null || toolbarProps === void 0 ? void 0 : toolbarProps.ref) {
                    toolbarProps.ref.current = node;
                }
            }
        }, children: [positionToolbarAlertBanner === 'top' && (jsxRuntime.jsx(MRT_ToolbarAlertBanner, { stackAlertBanner: stackAlertBanner, table: table })), ['both', 'top'].includes(positionToolbarDropZone !== null && positionToolbarDropZone !== void 0 ? positionToolbarDropZone : '') && (jsxRuntime.jsx(MRT_ToolbarDropZone, { table: table })), jsxRuntime.jsxs(core.Flex, { className: clsx(classes$g['actions-container'], stackAlertBanner && classes$g['actions-container-stack-alert']), children: [enableGlobalFilter && positionGlobalFilter === 'left' && (jsxRuntime.jsx(MRT_GlobalFilterTextInput, Object.assign({}, globalFilterProps))), (_a = renderTopToolbarCustomActions === null || renderTopToolbarCustomActions === void 0 ? void 0 : renderTopToolbarCustomActions({ table })) !== null && _a !== void 0 ? _a : jsxRuntime.jsx("span", {}), enableToolbarInternalActions ? (jsxRuntime.jsxs(core.Flex, { wrap: 'wrap-reverse', justify: 'end', children: [enableGlobalFilter && positionGlobalFilter === 'right' && (jsxRuntime.jsx(MRT_GlobalFilterTextInput, Object.assign({}, globalFilterProps))), jsxRuntime.jsx(MRT_ToolbarInternalButtons, { table: table })] })) : (enableGlobalFilter &&
                        positionGlobalFilter === 'right' && (jsxRuntime.jsx(MRT_GlobalFilterTextInput, Object.assign({}, globalFilterProps))))] }), enablePagination &&
                ['top', 'both'].includes(positionPagination !== null && positionPagination !== void 0 ? positionPagination : '') && (jsxRuntime.jsx(core.Flex, { justify: "end", children: jsxRuntime.jsx(MRT_TablePagination, { table: table, position: "top" }) })), jsxRuntime.jsx(MRT_ProgressBar, { isTopToolbar: true, table: table })] })));
};

var classes$f = {"root":"MRT_BottomToolbar-module_root__egbmt","bottom-toolbar-fullscreen":"MRT_BottomToolbar-module_bottom-toolbar-fullscreen__PRiML","custom-toolbar-container":"MRT_BottomToolbar-module_custom-toolbar-container__fH1YH","paginator-container":"MRT_BottomToolbar-module_paginator-container__7kgak","paginator-container-alert-banner":"MRT_BottomToolbar-module_paginator-container-alert-banner__tuMV-"};

const MRT_BottomToolbar = ({ table, }) => {
    const { getState, options: { enablePagination, mantineBottomToolbarProps, positionPagination, positionToolbarAlertBanner, positionToolbarDropZone, renderBottomToolbarCustomActions, }, refs: { bottomToolbarRef }, } = table;
    const { isFullScreen } = getState();
    const isMobile = hooks.useMediaQuery('(max-width: 720px)');
    const toolbarProps = parseFromValuesOrFunc(mantineBottomToolbarProps, {
        table,
    });
    const stackAlertBanner = isMobile || !!renderBottomToolbarCustomActions;
    return (jsxRuntime.jsxs(core.Box, Object.assign({}, toolbarProps, { ref: (node) => {
            if (node) {
                bottomToolbarRef.current = node;
                if (toolbarProps === null || toolbarProps === void 0 ? void 0 : toolbarProps.ref) {
                    toolbarProps.ref.current = node;
                }
            }
        }, className: clsx('mrt-bottom-toolbar', classes$f.root, commonClasses['common-toolbar-styles'], isFullScreen && classes$f['bottom-toolbar-fullscreen'], toolbarProps === null || toolbarProps === void 0 ? void 0 : toolbarProps.className), children: [jsxRuntime.jsx(MRT_ProgressBar, { isTopToolbar: false, table: table }), positionToolbarAlertBanner === 'bottom' && (jsxRuntime.jsx(MRT_ToolbarAlertBanner, { stackAlertBanner: stackAlertBanner, table: table })), ['both', 'bottom'].includes(positionToolbarDropZone !== null && positionToolbarDropZone !== void 0 ? positionToolbarDropZone : '') && (jsxRuntime.jsx(MRT_ToolbarDropZone, { table: table })), jsxRuntime.jsxs(core.Box, { className: classes$f['custom-toolbar-container'], children: [renderBottomToolbarCustomActions ? (renderBottomToolbarCustomActions({ table })) : (jsxRuntime.jsx("span", {})), jsxRuntime.jsx(core.Box, { className: clsx(classes$f['paginator-container'], stackAlertBanner && classes$f['paginator-container-alert-banner']), children: enablePagination &&
                            ['bottom', 'both'].includes(positionPagination !== null && positionPagination !== void 0 ? positionPagination : '') && (jsxRuntime.jsx(MRT_TablePagination, { table: table, position: "bottom" })) })] })] })));
};

var classes$e = {"left":"MRT_ColumnActionMenu-module_left__4iBP3","right":"MRT_ColumnActionMenu-module_right__7HTZK"};

const MRT_ColumnActionMenu = ({ header, table, }) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    const { getState, toggleAllColumnsVisible, setColumnOrder, options: { columnFilterDisplayMode, enableColumnFilters, enableColumnResizing, enableGrouping, enableHiding, enableColumnPinning, enableSorting, enableSortingRemoval, icons: { IconArrowAutofitContent, IconBoxMultiple, IconClearAll, IconColumns, IconDotsVertical, IconEyeOff, IconFilter, IconFilterOff, IconPinned, IconPinnedOff, IconSortAscending, IconSortDescending, }, localization, mantineColumnActionsButtonProps, renderColumnActionsMenuItems, }, refs: { filterInputRefs }, setColumnSizingInfo, setShowColumnFilters, } = table;
    const { column } = header;
    const { columnDef } = column;
    const { columnSizing, columnVisibility } = getState();
    const arg = { column, table };
    const actionIconProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(mantineColumnActionsButtonProps, arg)), parseFromValuesOrFunc(columnDef.mantineColumnActionsButtonProps, arg));
    const handleClearSort = () => {
        column.clearSorting();
    };
    const handleSortAsc = () => {
        column.toggleSorting(false);
    };
    const handleSortDesc = () => {
        column.toggleSorting(true);
    };
    const handleResetColumnSize = () => {
        setColumnSizingInfo((old) => (Object.assign(Object.assign({}, old), { isResizingColumn: false })));
        column.resetSize();
    };
    const handleHideColumn = () => {
        column.toggleVisibility(false);
    };
    const handlePinColumn = (pinDirection) => {
        column.pin(pinDirection);
    };
    const handleGroupByColumn = () => {
        column.toggleGrouping();
        setColumnOrder((old) => ['mrt-row-expand', ...old]);
    };
    const handleClearFilter = () => {
        column.setFilterValue('');
    };
    const handleFilterByColumn = () => {
        setShowColumnFilters(true);
        setTimeout(() => { var _a; return (_a = filterInputRefs.current[`${column.id}-0`]) === null || _a === void 0 ? void 0 : _a.focus(); }, 100);
    };
    const handleShowAllColumns = () => {
        toggleAllColumnsVisible(true);
    };
    const internalColumnMenuItems = (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [enableSorting && column.getCanSort() && (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [enableSortingRemoval !== false && (jsxRuntime.jsx(core.Menu.Item, { disabled: !column.getIsSorted(), leftSection: jsxRuntime.jsx(IconClearAll, {}), onClick: handleClearSort, children: localization.clearSort })), jsxRuntime.jsx(core.Menu.Item, { disabled: column.getIsSorted() === 'asc', leftSection: jsxRuntime.jsx(IconSortAscending, {}), onClick: handleSortAsc, children: (_a = localization.sortByColumnAsc) === null || _a === void 0 ? void 0 : _a.replace('{column}', String(columnDef.header)) }), jsxRuntime.jsx(core.Menu.Item, { leftSection: jsxRuntime.jsx(IconSortDescending, {}), disabled: column.getIsSorted() === 'desc', onClick: handleSortDesc, children: (_b = localization.sortByColumnDesc) === null || _b === void 0 ? void 0 : _b.replace('{column}', String(columnDef.header)) }), (enableColumnFilters || enableGrouping || enableHiding) && (jsxRuntime.jsx(core.Menu.Divider, {}, 3))] })), enableColumnFilters &&
                columnFilterDisplayMode !== 'popover' &&
                column.getCanFilter() && (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx(core.Menu.Item, { disabled: !column.getFilterValue(), leftSection: jsxRuntime.jsx(IconFilterOff, {}), onClick: handleClearFilter, children: localization.clearFilter }), jsxRuntime.jsx(core.Menu.Item, { leftSection: jsxRuntime.jsx(IconFilter, {}), onClick: handleFilterByColumn, children: (_c = localization.filterByColumn) === null || _c === void 0 ? void 0 : _c.replace('{column}', String(columnDef.header)) }), (enableGrouping || enableHiding) && jsxRuntime.jsx(core.Menu.Divider, {}, 2)] })), enableGrouping && column.getCanGroup() && (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx(core.Menu.Item, { leftSection: jsxRuntime.jsx(IconBoxMultiple, {}), onClick: handleGroupByColumn, children: (_d = localization[column.getIsGrouped() ? 'ungroupByColumn' : 'groupByColumn']) === null || _d === void 0 ? void 0 : _d.replace('{column}', String(columnDef.header)) }), enableColumnPinning && jsxRuntime.jsx(core.Menu.Divider, {})] })), enableColumnPinning && column.getCanPin() && (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx(core.Menu.Item, { disabled: column.getIsPinned() === 'left' || !column.getCanPin(), leftSection: jsxRuntime.jsx(IconPinned, { className: classes$e.left }), onClick: () => handlePinColumn('left'), children: localization.pinToLeft }), jsxRuntime.jsx(core.Menu.Item, { disabled: column.getIsPinned() === 'right' || !column.getCanPin(), leftSection: jsxRuntime.jsx(IconPinned, { className: classes$e.right }), onClick: () => handlePinColumn('right'), children: localization.pinToRight }), jsxRuntime.jsx(core.Menu.Item, { disabled: !column.getIsPinned(), leftSection: jsxRuntime.jsx(IconPinnedOff, {}), onClick: () => handlePinColumn(false), children: localization.unpin }), enableHiding && jsxRuntime.jsx(core.Menu.Divider, {})] })), enableColumnResizing && column.getCanResize() && (jsxRuntime.jsx(core.Menu.Item, { disabled: !columnSizing[column.id], leftSection: jsxRuntime.jsx(IconArrowAutofitContent, {}), onClick: handleResetColumnSize, children: localization.resetColumnSize }, 0)), enableHiding && (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx(core.Menu.Item, { disabled: !column.getCanHide(), leftSection: jsxRuntime.jsx(IconEyeOff, {}), onClick: handleHideColumn, children: (_e = localization.hideColumn) === null || _e === void 0 ? void 0 : _e.replace('{column}', String(columnDef.header)) }, 0), jsxRuntime.jsx(core.Menu.Item, { disabled: !Object.values(columnVisibility).filter((visible) => !visible)
                            .length, leftSection: jsxRuntime.jsx(IconColumns, {}), onClick: handleShowAllColumns, children: (_f = localization.showAllColumns) === null || _f === void 0 ? void 0 : _f.replace('{column}', String(columnDef.header)) }, 1)] }))] }));
    return (jsxRuntime.jsxs(core.Menu, { closeOnItemClick: true, withinPortal: true, position: "bottom-start", children: [jsxRuntime.jsx(core.Tooltip, { withinPortal: true, openDelay: 1000, label: (_g = actionIconProps === null || actionIconProps === void 0 ? void 0 : actionIconProps.title) !== null && _g !== void 0 ? _g : localization.columnActions, children: jsxRuntime.jsx(core.Menu.Target, { children: jsxRuntime.jsx(core.ActionIcon, Object.assign({ "aria-label": localization.columnActions }, actionIconProps, { size: "sm", color: "gray", variant: "subtle", children: jsxRuntime.jsx(IconDotsVertical, {}) })) }) }), jsxRuntime.jsx(core.Menu.Dropdown, { children: (_k = (_j = (_h = columnDef.renderColumnActionsMenuItems) === null || _h === void 0 ? void 0 : _h.call(columnDef, {
                    column,
                    table,
                    internalColumnMenuItems,
                })) !== null && _j !== void 0 ? _j : renderColumnActionsMenuItems === null || renderColumnActionsMenuItems === void 0 ? void 0 : renderColumnActionsMenuItems({
                    column,
                    table,
                    internalColumnMenuItems,
                })) !== null && _k !== void 0 ? _k : internalColumnMenuItems })] }));
};

var classes$d = {"root":"MRT_FilterRangeSlider-module_root__Q8OeH"};

const MRT_FilterRangeSlider = ({ header, table, }) => {
    var _a;
    const { options: { mantineFilterRangeSliderProps }, refs: { filterInputRefs }, } = table;
    const { column } = header;
    const { columnDef } = column;
    const arg = { column, table };
    const rangeSliderProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(mantineFilterRangeSliderProps, arg)), parseFromValuesOrFunc(columnDef.mantineFilterRangeSliderProps, arg));
    let [min, max] = rangeSliderProps.min !== undefined && rangeSliderProps.max !== undefined
        ? [rangeSliderProps.min, rangeSliderProps.max]
        : (_a = column.getFacetedMinMaxValues()) !== null && _a !== void 0 ? _a : [0, 1];
    //fix potential TanStack Table bugs where min or max is an array
    if (Array.isArray(min))
        min = min[0];
    if (Array.isArray(max))
        max = max[0];
    if (min === null)
        min = 0;
    if (max === null)
        max = 1;
    const [filterValues, setFilterValues] = react.useState([
        min,
        max,
    ]);
    const columnFilterValue = column.getFilterValue();
    const isMounted = react.useRef(false);
    react.useEffect(() => {
        if (isMounted.current) {
            if (columnFilterValue === undefined) {
                setFilterValues([min, max]);
            }
            else if (Array.isArray(columnFilterValue)) {
                setFilterValues(columnFilterValue);
            }
        }
        isMounted.current = true;
    }, [columnFilterValue, min, max]);
    return (jsxRuntime.jsx(core.RangeSlider, Object.assign({ className: clsx('mrt-filter-range-slider', classes$d.root), min: min, max: max, onChange: (values) => {
            setFilterValues(values);
        }, onChangeEnd: (values) => {
            if (Array.isArray(values)) {
                if (values[0] <= min && values[1] >= max) {
                    //if the user has selected the entire range, remove the filter
                    column.setFilterValue(undefined);
                }
                else {
                    column.setFilterValue(values);
                }
            }
        }, value: filterValues }, rangeSliderProps, { ref: (node) => {
            if (node) {
                //@ts-ignore
                filterInputRefs.current[`${column.id}-0`] = node;
                // @ts-ignore
                if (rangeSliderProps === null || rangeSliderProps === void 0 ? void 0 : rangeSliderProps.ref) {
                    //@ts-ignore
                    rangeSliderProps.ref = node;
                }
            }
        } })));
};

var classes$c = {"filter-mode-label":"MRT_TableHeadCellFilterContainer-module_filter-mode-label__knon-"};

const MRT_TableHeadCellFilterContainer = ({ header, table, }) => {
    var _a, _b;
    const { getState, options: { columnFilterDisplayMode, enableColumnFilterModes, columnFilterModeOptions, icons: { IconFilterCog }, localization, }, refs: { filterInputRefs }, } = table;
    const { showColumnFilters } = getState();
    const { column } = header;
    const { columnDef } = column;
    const currentFilterOption = columnDef._filterFn;
    const allowedColumnFilterOptions = (_a = columnDef === null || columnDef === void 0 ? void 0 : columnDef.columnFilterModeOptions) !== null && _a !== void 0 ? _a : columnFilterModeOptions;
    const showChangeModeButton = enableColumnFilterModes &&
        columnDef.enableColumnFilterModes !== false &&
        (allowedColumnFilterOptions === undefined ||
            !!(allowedColumnFilterOptions === null || allowedColumnFilterOptions === void 0 ? void 0 : allowedColumnFilterOptions.length));
    return (jsxRuntime.jsx(core.Collapse, { in: showColumnFilters || columnFilterDisplayMode === 'popover', children: jsxRuntime.jsxs(core.Flex, { direction: "column", children: [jsxRuntime.jsxs(core.Flex, { align: "flex-end", children: [columnDef.filterVariant === 'checkbox' ? (jsxRuntime.jsx(MRT_FilterCheckbox, { column: column, table: table })) : columnDef.filterVariant === 'range-slider' ? (jsxRuntime.jsx(MRT_FilterRangeSlider, { header: header, table: table })) : ['range', 'date-range'].includes((_b = columnDef.filterVariant) !== null && _b !== void 0 ? _b : '') ||
                            ['between', 'betweenInclusive', 'inNumberRange'].includes(columnDef._filterFn) ? (jsxRuntime.jsx(MRT_FilterRangeFields, { header: header, table: table })) : (jsxRuntime.jsx(MRT_FilterTextInput, { header: header, table: table })), showChangeModeButton && (jsxRuntime.jsxs(core.Menu, { withinPortal: columnFilterDisplayMode !== 'popover', children: [jsxRuntime.jsx(core.Tooltip, { label: localization.changeFilterMode, position: "bottom-start", withinPortal: true, children: jsxRuntime.jsx(core.Menu.Target, { children: jsxRuntime.jsx(core.ActionIcon, { color: "gray", variant: "subtle", "aria-label": localization.changeFilterMode, size: "md", children: jsxRuntime.jsx(IconFilterCog, {}) }) }) }), jsxRuntime.jsx(MRT_FilterOptionMenu, { header: header, table: table, onSelect: () => setTimeout(() => { var _a; return (_a = filterInputRefs.current[`${column.id}-0`]) === null || _a === void 0 ? void 0 : _a.focus(); }, 100) })] }))] }), showChangeModeButton ? (jsxRuntime.jsx(core.Text, { component: "label", className: classes$c['filter-mode-label'], c: "dimmed", children: localization.filterMode.replace('{filterType}', localizedFilterOption(localization, currentFilterOption)) })) : null] }) }));
};

var classes$b = {"root":"MRT_TableHeadCellFilterLabel-module_root__dBJ4L"};

const MRT_TableHeadCellFilterLabel = ({ header, table, }) => {
    var _a, _b, _c;
    const { options: { columnFilterDisplayMode, icons: { IconFilter }, localization, }, refs: { filterInputRefs }, setShowColumnFilters, } = table;
    const { column } = header;
    const { columnDef } = column;
    const filterValue = column.getFilterValue();
    const [popoverOpened, setPopoverOpened] = react.useState(false);
    const isFilterActive = (Array.isArray(filterValue) && filterValue.some(Boolean)) ||
        (!!filterValue && !Array.isArray(filterValue));
    const isRangeFilter = columnDef.filterVariant === 'range' ||
        ['between', 'betweenInclusive', 'inNumberRange'].includes(columnDef._filterFn);
    const currentFilterOption = columnDef._filterFn;
    const filterTooltip = columnFilterDisplayMode === 'popover' && !isFilterActive
        ? (_a = localization.filterByColumn) === null || _a === void 0 ? void 0 : _a.replace('{column}', String(columnDef.header))
        : localization.filteringByColumn
            .replace('{column}', String(columnDef.header))
            .replace('{filterType}', localizedFilterOption(localization, currentFilterOption))
            .replace('{filterValue}', `"${Array.isArray(column.getFilterValue())
            ? column.getFilterValue().join(`" ${isRangeFilter ? localization.and : localization.or} "`)
            : column.getFilterValue()}"`)
            .replace('" "', '');
    return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: jsxRuntime.jsxs(core.Popover, { onClose: () => setPopoverOpened(false), opened: popoverOpened, position: "top", keepMounted: columnDef.filterVariant === 'range-slider', shadow: "xl", width: 360, withinPortal: true, children: [jsxRuntime.jsx(core.Transition, { transition: "scale", mounted: columnFilterDisplayMode === 'popover' ||
                        (!!column.getFilterValue() && !isRangeFilter) ||
                        (isRangeFilter &&
                            (!!((_b = column.getFilterValue()) === null || _b === void 0 ? void 0 : _b[0]) ||
                                !!((_c = column.getFilterValue()) === null || _c === void 0 ? void 0 : _c[1]))), children: () => (jsxRuntime.jsx(core.Popover.Target, { children: jsxRuntime.jsx(core.Tooltip, { disabled: popoverOpened, label: filterTooltip, multiline: true, w: filterTooltip.length > 40 ? 300 : undefined, withinPortal: true, children: jsxRuntime.jsx(core.ActionIcon, Object.assign({ className: clsx('mrt-table-head-cell-filter-label-icon', classes$b.root), size: 18 }, dataVariable('active', isFilterActive), { onClick: (event) => {
                                    event.stopPropagation();
                                    if (columnFilterDisplayMode === 'popover') {
                                        setPopoverOpened((opened) => !opened);
                                    }
                                    else {
                                        setShowColumnFilters(true);
                                    }
                                    setTimeout(() => {
                                        const input = filterInputRefs.current[`${column.id}-0`];
                                        input === null || input === void 0 ? void 0 : input.focus();
                                        input === null || input === void 0 ? void 0 : input.select();
                                    }, 100);
                                }, children: jsxRuntime.jsx(IconFilter, {}) })) }) })) }), columnFilterDisplayMode === 'popover' && (jsxRuntime.jsx(core.Popover.Dropdown, { onClick: (event) => event.stopPropagation(), onKeyDown: (event) => event.key === 'Enter' && setPopoverOpened(false), children: jsxRuntime.jsx(MRT_TableHeadCellFilterContainer, { header: header, table: table }) }))] }) }));
};

const MRT_TableHeadCellGrabHandle = ({ column, table, tableHeadCellRef, }) => {
    const { getState, options: { enableColumnOrdering, mantineColumnDragHandleProps }, setColumnOrder, setDraggingColumn, setHoveredColumn, } = table;
    const { columnDef } = column;
    const { hoveredColumn, draggingColumn, columnOrder } = getState();
    const arg = { column, table };
    const actionIconProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(mantineColumnDragHandleProps, arg)), parseFromValuesOrFunc(columnDef.mantineColumnDragHandleProps, arg));
    const handleDragStart = (event) => {
        var _a;
        (_a = actionIconProps === null || actionIconProps === void 0 ? void 0 : actionIconProps.onDragStart) === null || _a === void 0 ? void 0 : _a.call(actionIconProps, event);
        setDraggingColumn(column);
        event.dataTransfer.setDragImage(tableHeadCellRef.current, 0, 0);
    };
    const handleDragEnd = (event) => {
        var _a;
        (_a = actionIconProps === null || actionIconProps === void 0 ? void 0 : actionIconProps.onDragEnd) === null || _a === void 0 ? void 0 : _a.call(actionIconProps, event);
        if ((hoveredColumn === null || hoveredColumn === void 0 ? void 0 : hoveredColumn.id) === 'drop-zone') {
            column.toggleGrouping();
        }
        else if (enableColumnOrdering &&
            hoveredColumn &&
            (hoveredColumn === null || hoveredColumn === void 0 ? void 0 : hoveredColumn.id) !== (draggingColumn === null || draggingColumn === void 0 ? void 0 : draggingColumn.id)) {
            setColumnOrder(reorderColumn(column, hoveredColumn, columnOrder));
        }
        setDraggingColumn(null);
        setHoveredColumn(null);
    };
    return (jsxRuntime.jsx(MRT_GrabHandleButton, { actionIconProps: actionIconProps, onDragStart: handleDragStart, onDragEnd: handleDragEnd, table: table }));
};

var classes$a = {"root":"MRT_TableHeadCellResizeHandle-module_root__JLf0R"};

const MRT_TableHeadCellResizeHandle = ({ header, table, }) => {
    var _a;
    const { getState, options: { columnResizeMode }, setColumnSizingInfo, } = table;
    const { density } = getState();
    const { column } = header;
    const handler = header.getResizeHandler();
    const offset = columnResizeMode === 'onEnd' && column.getIsResizing()
        ? `translateX(${(_a = getState().columnSizingInfo.deltaOffset) !== null && _a !== void 0 ? _a : 0}px)`
        : undefined;
    return (jsxRuntime.jsx(core.Box, { role: "separator", onMouseDown: handler, onTouchStart: handler, onDoubleClick: () => {
            setColumnSizingInfo((old) => (Object.assign(Object.assign({}, old), { isResizingColumn: false })));
            column.resetSize();
        }, className: clsx('mrt-table-head-cell-resize-handle', classes$a.root, density), __vars: { '--mrt-transform': offset } }));
};

var classes$9 = {"sort-icon":"MRT_TableHeadCellSortLabel-module_sort-icon__1Pgic","multi-sort-indicator":"MRT_TableHeadCellSortLabel-module_multi-sort-indicator__hPR7U"};

const MRT_TableHeadCellSortLabel = ({ header, table: { getState, options: { icons: { IconSortDescending, IconSortAscending, IconArrowsSort }, localization, }, }, }) => {
    const column = header.column;
    const { columnDef } = column;
    const { sorting } = getState();
    const sorted = column.getIsSorted();
    const sortIndex = column.getSortIndex();
    const sortTooltip = sorted
        ? sorted === 'desc'
            ? localization.sortedByColumnDesc.replace('{column}', columnDef.header)
            : localization.sortedByColumnAsc.replace('{column}', columnDef.header)
        : column.getNextSortingOrder() === 'desc'
            ? localization.sortByColumnDesc.replace('{column}', columnDef.header)
            : localization.sortByColumnAsc.replace('{column}', columnDef.header);
    return (jsxRuntime.jsx(core.Tooltip, { withinPortal: true, openDelay: 1000, label: sortTooltip, children: sorting.length < 2 || sortIndex === -1 ? (jsxRuntime.jsx(core.ActionIcon, Object.assign({ className: clsx('mrt-table-head-sort-button', classes$9['sort-icon']), "aria-label": sortTooltip, size: 18 }, dataVariable('sorted', sorted), { children: sorted === 'desc' ? (jsxRuntime.jsx(IconSortDescending, {})) : sorted === 'asc' ? (jsxRuntime.jsx(IconSortAscending, {})) : (jsxRuntime.jsx(IconArrowsSort, {})) }))) : (jsxRuntime.jsx(core.Indicator, { className: clsx('mrt-table-head-multi-sort-indicator', classes$9['multi-sort-indicator']), color: "transparent", label: sortIndex + 1, offset: 4, inline: true, children: jsxRuntime.jsx(core.ActionIcon, Object.assign({ className: clsx('mrt-table-head-sort-button', classes$9['sort-icon']), "aria-label": sortTooltip }, dataVariable('sorted', sorted), { children: sorted === 'desc' ? (jsxRuntime.jsx(IconSortDescending, {})) : sorted === 'asc' ? (jsxRuntime.jsx(IconSortAscending, {})) : (jsxRuntime.jsx(IconArrowsSort, {})) })) })) }));
};

var classes$8 = {"root":"MRT_TableHeadCell-module_root__ROjYZ","root-grid":"MRT_TableHeadCell-module_root-grid__3pJe7","root-virtualized":"MRT_TableHeadCell-module_root-virtualized__9D-BH","root-no-select":"MRT_TableHeadCell-module_root-no-select__rsQ7q","root-pinned":"MRT_TableHeadCell-module_root-pinned__lXd2o","root-pinned-left":"MRT_TableHeadCell-module_root-pinned-left__Xh-TW","root-pinned-right":"MRT_TableHeadCell-module_root-pinned-right__LxQAZ","root-pinned-left-last":"MRT_TableHeadCell-module_root-pinned-left-last__w7njO","root-pinned-right-first":"MRT_TableHeadCell-module_root-pinned-right-first__M2MbN","dragging":"MRT_TableHeadCell-module_dragging__K1xxG","hovered":"MRT_TableHeadCell-module_hovered__pCA-8","content":"MRT_TableHeadCell-module_content__47O7e","content-spaced":"MRT_TableHeadCell-module_content-spaced__PhAXB","content-center":"MRT_TableHeadCell-module_content-center__m9sXp","content-right":"MRT_TableHeadCell-module_content-right__iGCoI","content-wrapper":"MRT_TableHeadCell-module_content-wrapper__k-Rjy","content-wrapper-hidden-overflow":"MRT_TableHeadCell-module_content-wrapper-hidden-overflow__y9gFN","content-wrapper-nowrap":"MRT_TableHeadCell-module_content-wrapper-nowrap__vNojJ","labels":"MRT_TableHeadCell-module_labels__LWNk7","labels-right":"MRT_TableHeadCell-module_labels-right__I2gZy","labels-center":"MRT_TableHeadCell-module_labels-center__twd-q","labels-sortable":"MRT_TableHeadCell-module_labels-sortable__YB55b","labels-data":"MRT_TableHeadCell-module_labels-data__U4Iif","content-actions":"MRT_TableHeadCell-module_content-actions__A9UQq"};

const MRT_TableHeadCell = ({ header, table, }) => {
    var _a, _b, _c, _d;
    const { getState, options: { columnFilterDisplayMode, enableColumnActions, enableColumnDragging, enableColumnOrdering, enableGrouping, enableMultiSort, layoutMode, mantineTableHeadCellProps, }, refs: { tableHeadCellRefs }, setHoveredColumn, } = table;
    const { density, draggingColumn, grouping, hoveredColumn } = getState();
    const { column } = header;
    const { columnDef } = column;
    const { columnDefType } = columnDef;
    const arg = { column, table };
    const tableCellProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(mantineTableHeadCellProps, arg)), parseFromValuesOrFunc(columnDef.mantineTableHeadCellProps, arg));
    const widthStyles = react.useMemo(() => {
        var _a;
        const styles = {
            minWidth: `max(calc(var(--col-${parseCSSVarId(column.id)}-size) * 1px), ${(_a = column.columnDef.minSize) !== null && _a !== void 0 ? _a : 30}px)`,
            width: `calc(var(--col-${parseCSSVarId(column.id)}-size) * 1px)`,
        };
        if (layoutMode === 'grid') {
            styles.flex = `${column.getSize()} 0 auto`;
        }
        else if (layoutMode === 'grid-no-grow') {
            styles.flex = '0 0 auto';
        }
        return styles;
    }, [column]);
    const showColumnActions = (enableColumnActions || columnDef.enableColumnActions) &&
        columnDef.enableColumnActions !== false;
    const showDragHandle = enableColumnDragging !== false &&
        columnDef.enableColumnDragging !== false &&
        (enableColumnDragging ||
            (enableColumnOrdering && columnDef.enableColumnOrdering !== false) ||
            (enableGrouping &&
                columnDef.enableGrouping !== false &&
                !grouping.includes(column.id)));
    const headerPL = react.useMemo(() => {
        let pl = 0;
        if (column.getCanSort())
            pl++;
        if (showColumnActions)
            pl += 1.75;
        if (showDragHandle)
            pl += 1.25;
        return pl;
    }, [showColumnActions, showDragHandle]);
    const handleDragEnter = (_e) => {
        if (enableGrouping && (hoveredColumn === null || hoveredColumn === void 0 ? void 0 : hoveredColumn.id) === 'drop-zone') {
            setHoveredColumn(null);
        }
        if (enableColumnOrdering && draggingColumn && columnDefType !== 'group') {
            setHoveredColumn(columnDef.enableColumnOrdering !== false ? column : null);
        }
    };
    const headerElement = (columnDef === null || columnDef === void 0 ? void 0 : columnDef.Header) instanceof Function
        ? (_a = columnDef === null || columnDef === void 0 ? void 0 : columnDef.Header) === null || _a === void 0 ? void 0 : _a.call(columnDef, {
            column,
            header,
            table,
        })
        : (_b = columnDef === null || columnDef === void 0 ? void 0 : columnDef.Header) !== null && _b !== void 0 ? _b : columnDef.header;
    return (jsxRuntime.jsxs(core.TableTh, Object.assign({}, tableCellProps, { align: columnDefType === 'group' ? 'center' : 'left', colSpan: header.colSpan, onDragEnter: handleDragEnter, ref: (node) => {
            if (node) {
                tableHeadCellRefs.current[column.id] = node;
            }
        }, __vars: {
            '--mrt-table-head-cell-padding': density === 'xl' ? '23' : density === 'md' ? '16' : '10',
            '--mrt-table-head-cell-z-index': column.getIsResizing() || (draggingColumn === null || draggingColumn === void 0 ? void 0 : draggingColumn.id) === column.id
                ? '3'
                : column.getIsPinned() && columnDefType !== 'group'
                    ? '2'
                    : '1',
            '--mrt-table-cell-left': column.getIsPinned() === 'left'
                ? `${column.getStart('left')}`
                : undefined,
            '--mrt-table-cell-right': column.getIsPinned() === 'right'
                ? `${getTotalRight(table, column)}`
                : undefined,
        }, className: clsx(classes$8.root, (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith('grid')) && classes$8['root-grid'], enableMultiSort && column.getCanSort() && classes$8['root-no-select'], column.getIsPinned() &&
            column.columnDef.columnDefType !== 'group' &&
            classes$8['root-pinned'], column.getIsPinned() === 'left' && classes$8['root-pinned-left'], column.getIsPinned() === 'right' && classes$8['root-pinned-right'], getIsLastLeftPinnedColumn(table, column) &&
            classes$8['root-pinned-left-last'], getIsFirstRightPinnedColumn(column) &&
            classes$8['root-pinned-right-first'], tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.className, (draggingColumn === null || draggingColumn === void 0 ? void 0 : draggingColumn.id) === column.id && classes$8['dragging'], (draggingColumn === null || draggingColumn === void 0 ? void 0 : draggingColumn.id) !== column.id &&
            (hoveredColumn === null || hoveredColumn === void 0 ? void 0 : hoveredColumn.id) === column.id &&
            classes$8['hovered']), style: (theme) => (Object.assign(Object.assign({}, parseFromValuesOrFunc(tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.style, theme)), widthStyles)), children: [header.isPlaceholder ? null : (jsxRuntime.jsxs(core.Flex, { className: clsx('mrt-table-head-cell-content', classes$8.content, (columnDefType === 'group' || (tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.align) === 'center') &&
                    classes$8['content-center'], (tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.align) === 'right' && classes$8['content-right'], column.getCanResize() && classes$8['content-spaced']), children: [jsxRuntime.jsxs(core.Flex, { __vars: {
                            '--mrt-table-head-cell-labels-padding-left': `${headerPL}`,
                        }, className: clsx('mrt-table-head-cell-labels', classes$8.labels, column.getCanSort() &&
                            columnDefType !== 'group' &&
                            classes$8['labels-sortable'], (tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.align) === 'right'
                            ? classes$8['labels-right']
                            : (tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.align) === 'center' &&
                                classes$8['labels-center'], columnDefType === 'data' && classes$8['labels-data']), onClick: column.getToggleSortingHandler(), children: [jsxRuntime.jsx(core.Flex, { className: clsx('mrt-table-head-cell-content-wrapper', classes$8['content-wrapper'], columnDefType === 'data' &&
                                    classes$8['content-wrapper-hidden-overflow'], ((_d = (_c = columnDef.header) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0) < 20 &&
                                    classes$8['content-wrapper-nowrap']), title: columnDefType === 'data' ? columnDef.header : undefined, children: headerElement }), column.getCanFilter() && (jsxRuntime.jsx(MRT_TableHeadCellFilterLabel, { header: header, table: table })), column.getCanSort() && (jsxRuntime.jsx(MRT_TableHeadCellSortLabel, { header: header, table: table }))] }), columnDefType !== 'group' && (jsxRuntime.jsxs(core.Flex, { className: clsx('mrt-table-head-cell-content-actions', classes$8['content-actions']), children: [showDragHandle && (jsxRuntime.jsx(MRT_TableHeadCellGrabHandle, { column: column, table: table, tableHeadCellRef: {
                                    current: tableHeadCellRefs.current[column.id],
                                } })), showColumnActions && (jsxRuntime.jsx(MRT_ColumnActionMenu, { header: header, table: table }))] })), column.getCanResize() && (jsxRuntime.jsx(MRT_TableHeadCellResizeHandle, { header: header, table: table }))] })), columnFilterDisplayMode === 'subheader' && column.getCanFilter() && (jsxRuntime.jsx(MRT_TableHeadCellFilterContainer, { header: header, table: table }))] })));
};

var classes$7 = {"root":"MRT_TableHeadRow-module_root__qbU5Z","layout-mode-grid":"MRT_TableHeadRow-module_layout-mode-grid__qtVAx","sticky":"MRT_TableHeadRow-module_sticky__Z3pt-"};

const MRT_TableHeadRow = ({ headerGroup, table, columnVirtualizer, }) => {
    const { getState, options: { enableStickyHeader, layoutMode, mantineTableHeadRowProps }, } = table;
    const { isFullScreen } = getState();
    const { virtualColumns, virtualPaddingLeft, virtualPaddingRight } = columnVirtualizer !== null && columnVirtualizer !== void 0 ? columnVirtualizer : {};
    const tableRowProps = parseFromValuesOrFunc(mantineTableHeadRowProps, {
        headerGroup,
        table,
    });
    return (jsxRuntime.jsxs(core.TableTr, Object.assign({}, tableRowProps, { className: clsx(classes$7.root, (enableStickyHeader || isFullScreen) && classes$7.sticky, (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith('grid')) && classes$7['layout-mode-grid']), children: [virtualPaddingLeft ? (jsxRuntime.jsx(core.Box, { component: "th", display: "flex", w: virtualPaddingLeft })) : null, (virtualColumns !== null && virtualColumns !== void 0 ? virtualColumns : headerGroup.headers).map((headerOrVirtualHeader) => {
                const header = virtualColumns
                    ? headerGroup.headers[headerOrVirtualHeader.index]
                    : headerOrVirtualHeader;
                return (jsxRuntime.jsx(MRT_TableHeadCell, { header: header, table: table }, header.id));
            }), virtualPaddingRight ? (jsxRuntime.jsx(core.Box, { component: "th", display: "flex", w: virtualPaddingRight })) : null] })));
};

var classes$6 = {"root":"MRT_TableHead-module_root__KSxb-","root-grid":"MRT_TableHead-module_root-grid__OaIuG","root-table-row-group":"MRT_TableHead-module_root-table-row-group__U92m-","root-sticky":"MRT_TableHead-module_root-sticky__CEREV","banner-tr":"MRT_TableHead-module_banner-tr__4VzDy","banner-th":"MRT_TableHead-module_banner-th__T-46i","grid":"MRT_TableHead-module_grid__3tz1n"};

const MRT_TableHead = ({ table, columnVirtualizer, }) => {
    const { getHeaderGroups, getSelectedRowModel, getState, options: { enableStickyHeader, layoutMode, mantineTableHeadProps, positionToolbarAlertBanner, }, refs: { tableHeadRef }, } = table;
    const { isFullScreen, showAlertBanner } = getState();
    const tableHeadProps = parseFromValuesOrFunc(mantineTableHeadProps, {
        table,
    });
    const stickyHeader = enableStickyHeader || isFullScreen;
    return (jsxRuntime.jsx(core.TableThead, Object.assign({}, tableHeadProps, { ref: (ref) => {
            tableHeadRef.current = ref;
            if (tableHeadProps === null || tableHeadProps === void 0 ? void 0 : tableHeadProps.ref) {
                // @ts-ignore
                tableHeadProps.ref.current = ref;
            }
        }, className: clsx(classes$6.root, (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith('grid'))
            ? classes$6['root-grid']
            : classes$6['root-table-row-group'], stickyHeader && classes$6['root-sticky'], tableHeadProps === null || tableHeadProps === void 0 ? void 0 : tableHeadProps.className), pos: stickyHeader && (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith('grid')) ? 'sticky' : 'relative', children: positionToolbarAlertBanner === 'head-overlay' &&
            (showAlertBanner || getSelectedRowModel().rows.length > 0) ? (jsxRuntime.jsx(core.TableTr, { className: clsx(classes$6['banner-tr'], (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith('grid')) && classes$6.grid), children: jsxRuntime.jsx(core.TableTh, { colSpan: table.getVisibleLeafColumns().length, className: clsx(classes$6['banner-th'], (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith('grid')) && classes$6.grid), children: jsxRuntime.jsx(MRT_ToolbarAlertBanner, { table: table }) }) })) : (getHeaderGroups().map((headerGroup) => (jsxRuntime.jsx(MRT_TableHeadRow, { headerGroup: headerGroup, table: table, columnVirtualizer: columnVirtualizer }, headerGroup.id)))) })));
};

var classes$5 = {"root":"MRT_TableFooterCell-module_root__8Iy27","pinned":"MRT_TableFooterCell-module_pinned__fHBaK","grid":"MRT_TableFooterCell-module_grid__2gAm-","group":"MRT_TableFooterCell-module_group__aZunC"};

const MRT_TableFooterCell = ({ footer, table, }) => {
    var _a;
    const { options: { layoutMode, mantineTableFooterCellProps }, } = table;
    const { column } = footer;
    const { columnDef } = column;
    const { columnDefType } = columnDef;
    const arg = { column, table };
    const _b = Object.assign(Object.assign({}, parseFromValuesOrFunc(mantineTableFooterCellProps, arg)), parseFromValuesOrFunc(columnDef.mantineTableFooterCellProps, arg)), { className } = _b, tableCellProps = __rest(_b, ["className"]);
    const footerProps = footer.isPlaceholder
        ? null
        : (_a = parseFromValuesOrFunc(columnDef.Footer, {
            column,
            footer,
            table,
        })) !== null && _a !== void 0 ? _a : columnDef === null || columnDef === void 0 ? void 0 : columnDef.footer;
    return (jsxRuntime.jsx(core.TableTh, Object.assign({ colSpan: footer.colSpan }, tableCellProps, { className: clsx(classes$5.root, (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith('grid')) && classes$5.grid, column.getIsPinned() && columnDefType !== 'group' && classes$5.pinned, columnDefType === 'group' && classes$5.group, className), children: jsxRuntime.jsx(jsxRuntime.Fragment, { children: footerProps }) })));
};

var classes$4 = {"root":"MRT_TableFooterRow-module_root__7cLvQ","layout-mode-grid":"MRT_TableFooterRow-module_layout-mode-grid__miQGS"};

const MRT_TableFooterRow = ({ footerGroup, table, columnVirtualizer, }) => {
    var _a;
    const { options: { layoutMode, mantineTableFooterRowProps }, } = table;
    const { virtualColumns, virtualPaddingLeft, virtualPaddingRight } = columnVirtualizer !== null && columnVirtualizer !== void 0 ? columnVirtualizer : {};
    // if no content in row, skip row
    if (!((_a = footerGroup.headers) === null || _a === void 0 ? void 0 : _a.some((header) => (typeof header.column.columnDef.footer === 'string' &&
        !!header.column.columnDef.footer) ||
        header.column.columnDef.Footer)))
        return null;
    const tableRowProps = parseFromValuesOrFunc(mantineTableFooterRowProps, {
        footerGroup,
        table,
    });
    return (jsxRuntime.jsxs(core.TableTr, Object.assign({ className: clsx(classes$4.root, (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith('grid')) && classes$4['layout-mode-grid']) }, tableRowProps, { children: [virtualPaddingLeft ? (jsxRuntime.jsx(core.Box, { component: "th", display: "flex", w: virtualPaddingLeft })) : null, (virtualColumns !== null && virtualColumns !== void 0 ? virtualColumns : footerGroup.headers).map((footerOrVirtualFooter) => {
                const footer = virtualColumns
                    ? footerGroup.headers[footerOrVirtualFooter.index]
                    : footerOrVirtualFooter;
                return (jsxRuntime.jsx(MRT_TableFooterCell, { footer: footer, table: table }, footer.id));
            }), virtualPaddingRight ? (jsxRuntime.jsx(core.Box, { component: "th", display: "flex", w: virtualPaddingRight })) : null] })));
};

var classes$3 = {"root":"MRT_TableFooter-module_root__0y9bn","grid":"MRT_TableFooter-module_grid__5g9HT","sticky":"MRT_TableFooter-module_sticky__65QE2"};

const MRT_TableFooter = ({ table, columnVirtualizer, }) => {
    const { getFooterGroups, getState, options: { enableStickyFooter, layoutMode, mantineTableFooterProps }, refs: { tableFooterRef }, } = table;
    const { isFullScreen } = getState();
    const tableFooterProps = parseFromValuesOrFunc(mantineTableFooterProps, {
        table,
    });
    const stickFooter = (isFullScreen || enableStickyFooter) && enableStickyFooter !== false;
    return (jsxRuntime.jsx(core.TableTfoot, Object.assign({}, tableFooterProps, { ref: (ref) => {
            tableFooterRef.current = ref;
            if (tableFooterProps === null || tableFooterProps === void 0 ? void 0 : tableFooterProps.ref) {
                // @ts-ignore
                tableFooterProps.ref.current = ref;
            }
        }, className: clsx(classes$3.root, tableFooterProps === null || tableFooterProps === void 0 ? void 0 : tableFooterProps.className, stickFooter && classes$3.sticky, (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith('grid')) && classes$3.grid), children: getFooterGroups().map((footerGroup) => (jsxRuntime.jsx(MRT_TableFooterRow, { footerGroup: footerGroup, table: table, columnVirtualizer: columnVirtualizer }, footerGroup.id))) })));
};

const useMRT_ColumnVirtualizer = (table) => {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const { getState, options: { columnVirtualizerInstanceRef, columnVirtualizerOptions, enableColumnPinning, enableColumnVirtualization, }, refs: { tableContainerRef }, } = table;
    const { columnPinning, columnVisibility, draggingColumn } = getState();
    const columnVirtualizerProps = parseFromValuesOrFunc(columnVirtualizerOptions, {
        table,
    });
    const [leftPinnedIndexes, rightPinnedIndexes] = react.useMemo(() => enableColumnVirtualization && enableColumnPinning
        ? [
            table.getLeftLeafColumns().map((c) => c.getPinnedIndex()),
            table
                .getRightLeafColumns()
                .map((c) => table.getVisibleLeafColumns().length - c.getPinnedIndex() - 1)
                .sort((a, b) => a - b),
        ]
        : [[], []], [columnPinning, enableColumnVirtualization, enableColumnPinning]);
    //get first 16 column widths and average them if calc is needed
    const averageColumnWidth = react.useMemo(() => {
        var _a, _b, _c, _d;
        if (!enableColumnVirtualization || (columnVirtualizerProps === null || columnVirtualizerProps === void 0 ? void 0 : columnVirtualizerProps.estimateSize)) {
            return 0;
        }
        const columnsWidths = (_d = (_c = (_b = (_a = table
            .getRowModel()
            .rows[0]) === null || _a === void 0 ? void 0 : _a.getCenterVisibleCells()) === null || _b === void 0 ? void 0 : _b.slice(0, 16)) === null || _c === void 0 ? void 0 : _c.map((cell) => cell.column.getSize() * 1.2)) !== null && _d !== void 0 ? _d : [];
        return columnsWidths.reduce((a, b) => a + b, 0) / columnsWidths.length;
    }, [table.getRowModel().rows, columnPinning, columnVisibility]);
    const draggingColumnIndex = (draggingColumn === null || draggingColumn === void 0 ? void 0 : draggingColumn.id)
        ? table
            .getVisibleLeafColumns()
            .findIndex((c) => c.id === (draggingColumn === null || draggingColumn === void 0 ? void 0 : draggingColumn.id))
        : undefined;
    const columnVirtualizer = enableColumnVirtualization
        ? reactVirtual.useVirtualizer(Object.assign({ count: table.getVisibleLeafColumns().length, estimateSize: () => averageColumnWidth, getScrollElement: () => tableContainerRef.current, horizontal: true, overscan: 3, rangeExtractor: react.useCallback((range) => {
                const newIndexes = extraIndexRangeExtractor(range, draggingColumnIndex);
                return [
                    ...new Set([
                        ...leftPinnedIndexes,
                        ...newIndexes,
                        ...rightPinnedIndexes,
                    ]),
                ];
            }, [leftPinnedIndexes, rightPinnedIndexes, draggingColumnIndex]) }, columnVirtualizerProps))
        : undefined;
    if (columnVirtualizer) {
        const virtualColumns = columnVirtualizer.getVirtualItems();
        columnVirtualizer.virtualColumns = virtualColumns;
        if (virtualColumns.length) {
            columnVirtualizer.virtualPaddingLeft =
                ((_b = (_a = virtualColumns[leftPinnedIndexes.length]) === null || _a === void 0 ? void 0 : _a.start) !== null && _b !== void 0 ? _b : 0) -
                    ((_d = (_c = virtualColumns[leftPinnedIndexes.length - 1]) === null || _c === void 0 ? void 0 : _c.end) !== null && _d !== void 0 ? _d : 0);
            columnVirtualizer.virtualPaddingRight =
                columnVirtualizer.getTotalSize() -
                    ((_f = (_e = virtualColumns[virtualColumns.length - rightPinnedIndexes.length - 1]) === null || _e === void 0 ? void 0 : _e.end) !== null && _f !== void 0 ? _f : 0) -
                    (rightPinnedIndexes.length
                        ? columnVirtualizer.getTotalSize() -
                            ((_h = (_g = virtualColumns[virtualColumns.length - rightPinnedIndexes.length]) === null || _g === void 0 ? void 0 : _g.start) !== null && _h !== void 0 ? _h : 0)
                        : 0);
        }
        if (columnVirtualizerInstanceRef) {
            //@ts-ignore
            columnVirtualizerInstanceRef.current = columnVirtualizer;
        }
    }
    return columnVirtualizer;
};

var classes$2 = {"root-grid":"MRT_Table-module_root-grid__q99se","root-semantic-not-resizing":"MRT_Table-module_root-semantic-not-resizing__1cDCm"};

const MRT_Table = ({ table, }) => {
    const { getFlatHeaders, getState, options: { columns, enableColumnResizing, enableTableFooter, enableTableHead, layoutMode, mantineTableProps, memoMode, }, } = table;
    const { columnSizing, columnSizingInfo, columnVisibility, density } = getState();
    const tableProps = parseFromValuesOrFunc(mantineTableProps, { table });
    const columnSizeVars = react.useMemo(() => {
        const headers = getFlatHeaders();
        const colSizes = {};
        for (let i = 0; i < headers.length; i++) {
            const header = headers[i];
            const colSize = header.getSize();
            colSizes[`--header-${parseCSSVarId(header.id)}-size`] = colSize;
            colSizes[`--col-${parseCSSVarId(header.column.id)}-size`] = colSize;
        }
        return colSizes;
    }, [columns, columnSizing, columnSizingInfo, columnVisibility]);
    const columnVirtualizer = useMRT_ColumnVirtualizer(table);
    const commonTableGroupProps = {
        columnVirtualizer,
        enableHover: tableProps === null || tableProps === void 0 ? void 0 : tableProps.highlightOnHover,
        isStriped: tableProps === null || tableProps === void 0 ? void 0 : tableProps.striped,
        table,
    };
    return (jsxRuntime.jsxs(core.Table, Object.assign({ className: clsx('mrt-table', (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith('grid')) && classes$2['root-grid'], enableColumnResizing &&
            layoutMode === 'semantic' &&
            classes$2['root-semantic-not-resizing'], tableProps === null || tableProps === void 0 ? void 0 : tableProps.className), highlightOnHover: true, horizontalSpacing: density, verticalSpacing: density }, tableProps, { __vars: Object.assign(Object.assign({}, columnSizeVars), tableProps === null || tableProps === void 0 ? void 0 : tableProps.__vars), children: [enableTableHead && jsxRuntime.jsx(MRT_TableHead, Object.assign({}, commonTableGroupProps)), memoMode === 'table-body' || columnSizingInfo.isResizingColumn ? (jsxRuntime.jsx(Memo_MRT_TableBody, Object.assign({}, commonTableGroupProps))) : (jsxRuntime.jsx(MRT_TableBody, Object.assign({}, commonTableGroupProps))), enableTableFooter && jsxRuntime.jsx(MRT_TableFooter, Object.assign({}, commonTableGroupProps))] })));
};

const MRT_EditRowModal = ({ open, table, }) => {
    var _a;
    const { getState, options: { onEditingRowCancel, onCreatingRowCancel, renderEditRowModalContent, renderCreateRowModalContent, mantineCreateRowModalProps, mantineEditRowModalProps, }, setEditingRow, setCreatingRow, } = table;
    const { creatingRow, editingRow } = getState();
    const row = (creatingRow !== null && creatingRow !== void 0 ? creatingRow : editingRow);
    const arg = { row, table };
    const modalProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(mantineEditRowModalProps, arg)), (creatingRow && parseFromValuesOrFunc(mantineCreateRowModalProps, arg)));
    const internalEditComponents = row
        .getAllCells()
        .filter((cell) => cell.column.columnDef.columnDefType === 'data')
        .map((cell) => (jsxRuntime.jsx(MRT_EditCellTextInput, { cell: cell, table: table }, cell.id)));
    const handleCancel = () => {
        var _a;
        if (creatingRow) {
            onCreatingRowCancel === null || onCreatingRowCancel === void 0 ? void 0 : onCreatingRowCancel({ row, table });
            setCreatingRow(null);
        }
        else {
            onEditingRowCancel === null || onEditingRowCancel === void 0 ? void 0 : onEditingRowCancel({ row, table });
            setEditingRow(null);
        }
        row._valuesCache = {}; //reset values cache
        (_a = modalProps.onClose) === null || _a === void 0 ? void 0 : _a.call(modalProps);
    };
    return (react.createElement(core.Modal, Object.assign({ opened: open, withCloseButton: false }, modalProps, { onClose: handleCancel, key: row.id }), (_a = ((creatingRow &&
        (renderCreateRowModalContent === null || renderCreateRowModalContent === void 0 ? void 0 : renderCreateRowModalContent({
            row,
            table,
            internalEditComponents,
        }))) ||
        (renderEditRowModalContent === null || renderEditRowModalContent === void 0 ? void 0 : renderEditRowModalContent({
            row,
            table,
            internalEditComponents,
        })))) !== null && _a !== void 0 ? _a : (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx("form", { onSubmit: (e) => e.preventDefault(), children: jsxRuntime.jsx(core.Stack, { gap: "lg", pt: 16, pb: 24, children: internalEditComponents }) }), jsxRuntime.jsx(core.Flex, { justify: "flex-end", children: jsxRuntime.jsx(MRT_EditActionButtons, { row: row, table: table, variant: "text" }) })] }))));
};

var classes$1 = {"root":"MRT_TableContainer-module_root__d16Nu","root-sticky":"MRT_TableContainer-module_root-sticky__tBBjf","root-fullscreen":"MRT_TableContainer-module_root-fullscreen__bf-9I"};

const useIsomorphicLayoutEffect = typeof window !== 'undefined' ? react.useLayoutEffect : react.useEffect;
const MRT_TableContainer = ({ table, }) => {
    const { getState, options: { createDisplayMode, editDisplayMode, enableStickyHeader, mantineLoadingOverlayProps, mantineTableContainerProps, }, refs: { tableContainerRef, bottomToolbarRef, topToolbarRef }, } = table;
    const { isFullScreen, isLoading, showLoadingOverlay, creatingRow, editingRow, } = getState();
    const [totalToolbarHeight, setTotalToolbarHeight] = react.useState(0);
    const tableContainerProps = parseFromValuesOrFunc(mantineTableContainerProps, { table });
    const loadingOverlayProps = parseFromValuesOrFunc(mantineLoadingOverlayProps, { table });
    useIsomorphicLayoutEffect(() => {
        var _a, _b, _c, _d;
        const topToolbarHeight = typeof document !== 'undefined'
            ? (_b = (_a = topToolbarRef.current) === null || _a === void 0 ? void 0 : _a.offsetHeight) !== null && _b !== void 0 ? _b : 0
            : 0;
        const bottomToolbarHeight = typeof document !== 'undefined'
            ? (_d = (_c = bottomToolbarRef === null || bottomToolbarRef === void 0 ? void 0 : bottomToolbarRef.current) === null || _c === void 0 ? void 0 : _c.offsetHeight) !== null && _d !== void 0 ? _d : 0
            : 0;
        setTotalToolbarHeight(topToolbarHeight + bottomToolbarHeight);
    });
    const createModalOpen = createDisplayMode === 'modal' && creatingRow;
    const editModalOpen = editDisplayMode === 'modal' && editingRow;
    return (jsxRuntime.jsxs(core.Box, Object.assign({}, tableContainerProps, { className: clsx('mrt-table-container', classes$1.root, enableStickyHeader && classes$1['root-sticky'], isFullScreen && classes$1['root-fullscreen'], tableContainerProps === null || tableContainerProps === void 0 ? void 0 : tableContainerProps.className), ref: (node) => {
            if (node) {
                tableContainerRef.current = node;
                if (tableContainerProps === null || tableContainerProps === void 0 ? void 0 : tableContainerProps.ref) {
                    //@ts-ignore
                    tableContainerProps.ref.current = node;
                }
            }
        }, __vars: Object.assign({ '--mrt-top-toolbar-height': `${totalToolbarHeight}` }, tableContainerProps === null || tableContainerProps === void 0 ? void 0 : tableContainerProps.__vars), children: [jsxRuntime.jsx(core.LoadingOverlay, Object.assign({ visible: isLoading || showLoadingOverlay, zIndex: 2 }, loadingOverlayProps)), jsxRuntime.jsx(MRT_Table, { table: table }), (createModalOpen || editModalOpen) && (jsxRuntime.jsx(MRT_EditRowModal, { open: true, table: table }))] })));
};

var classes = {"root":"MRT_TablePaper-module_root__W5OvZ"};

const MRT_TablePaper = ({ table, }) => {
    var _a, _b;
    const { getState, options: { enableBottomToolbar, enableTopToolbar, mantinePaperProps, renderBottomToolbar, renderTopToolbar, }, refs: { tablePaperRef }, } = table;
    const { isFullScreen } = getState();
    const tablePaperProps = parseFromValuesOrFunc(mantinePaperProps, { table });
    return (jsxRuntime.jsxs(core.Paper, Object.assign({ shadow: "xs", withBorder: true }, tablePaperProps, { className: clsx('mrt-table-paper', classes.root, isFullScreen && 'mrt-table-paper-fullscreen', tablePaperProps === null || tablePaperProps === void 0 ? void 0 : tablePaperProps.className), ref: (ref) => {
            tablePaperRef.current = ref;
            if (tablePaperProps === null || tablePaperProps === void 0 ? void 0 : tablePaperProps.ref) {
                tablePaperProps.ref.current = ref;
            }
        }, 
        // rare case where we should use inline styles to guarantee highest specificity
        style: (theme) => (Object.assign(Object.assign({}, (isFullScreen
            ? {
                bottom: 0,
                height: '100vh',
                left: 0,
                margin: 0,
                maxHeight: '100vh',
                maxWidth: '100vw',
                padding: 0,
                position: 'fixed',
                right: 0,
                top: 0,
                width: '100vw',
                zIndex: 100,
            }
            : null)), parseFromValuesOrFunc(tablePaperProps === null || tablePaperProps === void 0 ? void 0 : tablePaperProps.style, theme))), children: [enableTopToolbar &&
                ((_a = parseFromValuesOrFunc(renderTopToolbar, { table })) !== null && _a !== void 0 ? _a : (jsxRuntime.jsx(MRT_TopToolbar, { table: table }))), jsxRuntime.jsx(MRT_TableContainer, { table: table }), enableBottomToolbar &&
                ((_b = parseFromValuesOrFunc(renderBottomToolbar, { table })) !== null && _b !== void 0 ? _b : (jsxRuntime.jsx(MRT_BottomToolbar, { table: table })))] })));
};

const isTableInstanceProp = (props) => props.table !== undefined;
const MantineReactTable = (props) => {
    let table;
    if (isTableInstanceProp(props)) {
        table = props.table;
    }
    else {
        table = useMantineReactTable(props);
    }
    return jsxRuntime.jsx(MRT_TablePaper, { table: table });
};

exports.MRT_AggregationFns = MRT_AggregationFns;
exports.MRT_BottomToolbar = MRT_BottomToolbar;
exports.MRT_ColumnActionMenu = MRT_ColumnActionMenu;
exports.MRT_ColumnPinningButtons = MRT_ColumnPinningButtons;
exports.MRT_CopyButton = MRT_CopyButton;
exports.MRT_DefaultColumn = MRT_DefaultColumn;
exports.MRT_DefaultDisplayColumn = MRT_DefaultDisplayColumn;
exports.MRT_EditActionButtons = MRT_EditActionButtons;
exports.MRT_EditCellTextInput = MRT_EditCellTextInput;
exports.MRT_EditRowModal = MRT_EditRowModal;
exports.MRT_ExpandAllButton = MRT_ExpandAllButton;
exports.MRT_ExpandButton = MRT_ExpandButton;
exports.MRT_FilterCheckbox = MRT_FilterCheckbox;
exports.MRT_FilterFns = MRT_FilterFns;
exports.MRT_FilterOptionMenu = MRT_FilterOptionMenu;
exports.MRT_FilterRangeFields = MRT_FilterRangeFields;
exports.MRT_FilterTextInput = MRT_FilterTextInput;
exports.MRT_GlobalFilterTextInput = MRT_GlobalFilterTextInput;
exports.MRT_GrabHandleButton = MRT_GrabHandleButton;
exports.MRT_ProgressBar = MRT_ProgressBar;
exports.MRT_RowActionMenu = MRT_RowActionMenu;
exports.MRT_SelectCheckbox = MRT_SelectCheckbox;
exports.MRT_ShowHideColumnsButton = MRT_ShowHideColumnsButton;
exports.MRT_ShowHideColumnsMenu = MRT_ShowHideColumnsMenu;
exports.MRT_ShowHideColumnsMenuItems = MRT_ShowHideColumnsMenuItems;
exports.MRT_SortingFns = MRT_SortingFns;
exports.MRT_Table = MRT_Table;
exports.MRT_TableBody = MRT_TableBody;
exports.MRT_TableBodyCell = MRT_TableBodyCell;
exports.MRT_TableBodyCellValue = MRT_TableBodyCellValue;
exports.MRT_TableBodyRow = MRT_TableBodyRow;
exports.MRT_TableBodyRowGrabHandle = MRT_TableBodyRowGrabHandle;
exports.MRT_TableContainer = MRT_TableContainer;
exports.MRT_TableDetailPanel = MRT_TableDetailPanel;
exports.MRT_TableFooter = MRT_TableFooter;
exports.MRT_TableFooterCell = MRT_TableFooterCell;
exports.MRT_TableFooterRow = MRT_TableFooterRow;
exports.MRT_TableHead = MRT_TableHead;
exports.MRT_TableHeadCell = MRT_TableHeadCell;
exports.MRT_TableHeadCellFilterContainer = MRT_TableHeadCellFilterContainer;
exports.MRT_TableHeadCellFilterLabel = MRT_TableHeadCellFilterLabel;
exports.MRT_TableHeadCellGrabHandle = MRT_TableHeadCellGrabHandle;
exports.MRT_TableHeadCellResizeHandle = MRT_TableHeadCellResizeHandle;
exports.MRT_TableHeadCellSortLabel = MRT_TableHeadCellSortLabel;
exports.MRT_TableHeadRow = MRT_TableHeadRow;
exports.MRT_TablePagination = MRT_TablePagination;
exports.MRT_TablePaper = MRT_TablePaper;
exports.MRT_ToggleDensePaddingButton = MRT_ToggleDensePaddingButton;
exports.MRT_ToggleFiltersButton = MRT_ToggleFiltersButton;
exports.MRT_ToggleFullScreenButton = MRT_ToggleFullScreenButton;
exports.MRT_ToggleGlobalFilterButton = MRT_ToggleGlobalFilterButton;
exports.MRT_ToggleRowActionMenuButton = MRT_ToggleRowActionMenuButton;
exports.MRT_ToolbarAlertBanner = MRT_ToolbarAlertBanner;
exports.MRT_ToolbarDropZone = MRT_ToolbarDropZone;
exports.MRT_ToolbarInternalButtons = MRT_ToolbarInternalButtons;
exports.MRT_TopToolbar = MRT_TopToolbar;
exports.MantineReactTable = MantineReactTable;
exports.Memo_MRT_TableBody = Memo_MRT_TableBody;
exports.Memo_MRT_TableBodyCell = Memo_MRT_TableBodyCell;
exports.Memo_MRT_TableBodyRow = Memo_MRT_TableBodyRow;
exports.createMRTColumnHelper = createMRTColumnHelper;
exports.createRow = createRow;
exports.extraIndexRangeExtractor = extraIndexRangeExtractor;
exports.flexRender = flexRender;
exports.getAllLeafColumnDefs = getAllLeafColumnDefs;
exports.getCanRankRows = getCanRankRows;
exports.getColumnId = getColumnId;
exports.getDefaultColumnFilterFn = getDefaultColumnFilterFn;
exports.getDefaultColumnOrderIds = getDefaultColumnOrderIds;
exports.getIsFirstColumn = getIsFirstColumn;
exports.getIsFirstRightPinnedColumn = getIsFirstRightPinnedColumn;
exports.getIsLastColumn = getIsLastColumn;
exports.getIsLastLeftPinnedColumn = getIsLastLeftPinnedColumn;
exports.getLeadingDisplayColumnIds = getLeadingDisplayColumnIds;
exports.getPrimaryColor = getPrimaryColor;
exports.getPrimaryShade = getPrimaryShade;
exports.getTotalRight = getTotalRight;
exports.getTrailingDisplayColumnIds = getTrailingDisplayColumnIds;
exports.getValueAndLabel = getValueAndLabel;
exports.localizedFilterOption = localizedFilterOption;
exports.mrtFilterOptions = mrtFilterOptions;
exports.parseCSSVarId = parseCSSVarId;
exports.parseFromValuesOrFunc = parseFromValuesOrFunc;
exports.prepareColumns = prepareColumns;
exports.rankGlobalFuzzy = rankGlobalFuzzy;
exports.reorderColumn = reorderColumn;
exports.showExpandColumn = showExpandColumn;
exports.useMRT_ColumnVirtualizer = useMRT_ColumnVirtualizer;
exports.useMRT_DisplayColumns = useMRT_DisplayColumns;
exports.useMRT_Effects = useMRT_Effects;
exports.useMRT_RowVirtualizer = useMRT_RowVirtualizer;
exports.useMRT_Rows = useMRT_Rows;
exports.useMRT_TableInstance = useMRT_TableInstance;
exports.useMRT_TableOptions = useMRT_TableOptions;
exports.useMantineReactTable = useMantineReactTable;
//# sourceMappingURL=index.js.map
